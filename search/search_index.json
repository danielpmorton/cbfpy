{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#cbfpy-control-barrier-functions-in-python-and-jax","title":"CBFpy: Control Barrier Functions in Python and Jax","text":"<p>CBFpy is an easy-to-use and high-performance framework for constructing and solving Control Barrier Functions (CBFs) and Control Lyapunov Functions (CLFs), using Jax for:</p> <ul> <li>Just-in-time compilation</li> <li>Accelerated linear algebra operations with XLA</li> <li>Automatic differentiation</li> </ul> <p>For API reference, see the following documentation</p> <p>If you use CBFpy in your research, please cite the following paper:</p> <pre><code>@article{morton2025oscbf,\n  author = {Morton, Daniel and Pavone, Marco},\n  title = {Safe, Task-Consistent Manipulation with Operational Space Control Barrier Functions},\n  year = {2025},\n  journal = {arXiv preprint arXiv:2503.06736},\n  note = {Accepted to IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), Hangzhou, 2025},\n}\n</code></pre> <p></p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-pypi","title":"From PyPI","text":"<pre><code>pip install cbfpy\n</code></pre>"},{"location":"#from-source","title":"From source","text":"<p>A virtual environment is optional, but highly recommended. For <code>pyenv</code> installation instructions, see here.</p> <p><pre><code>git clone https://github.com/danielpmorton/cbfpy\ncd cbfpy\npip install -e \".[examples]\"\n</code></pre> The <code>[examples]</code> tag installs all of the required packages for development and running the examples. The pure <code>cbfpy</code> functionality does not require these extra packages though. If you want to contribute to the repo, you can also include the <code>[dev]</code> dependencies.</p> <p>If you are working on Apple silicon and have issues installing Jax, the following threads may be useful: [1], [2]</p>"},{"location":"#usage","title":"Usage:","text":""},{"location":"#example-a-point-mass-robot-in-1d-with-an-applied-force-and-a-positional-barrier","title":"Example: A point-mass robot in 1D with an applied force and a positional barrier","text":"<p>For this problem, the state \\(z\\) is defined as the position and velocity of the robot,</p> \\[z = [x, \\dot{x}]\\] <p>So, the state derivative \\(\\dot{z}\\) is therefore</p> \\[\\dot{z} = [\\dot{x}, \\ddot{x}]\\] <p>And the control input is the applied force in the \\(x\\) direction:</p> \\[u = F_{x}\\] <p>The dynamics can be expressed as follows (with \\(m\\) denoting the robot's mass):</p> \\[\\dot{z} = \\begin{bmatrix}0 &amp; 1 \\\\                            0 &amp; 0             \\end{bmatrix}z +              \\begin{bmatrix}0 \\\\                           1/m             \\end{bmatrix} u\\] <p>This is a control affine system, since the dynamics can be expressed as </p> \\[\\dot{z} = f(z) + g(z) u\\] <p>If the robot is controlled by some nominal (unsafe) controller, we may want to guarantee that it remains in some safe region. If we define \\(X_{safe} \\in [x_{min}, \\infty]\\), we can construct a (relative-degree-2, zeroing) barrier \\(h\\) where \\(h(z) \\geq 0\\) for any \\(z\\) in the safe set:</p> \\[h(z) = x - x_{min}\\]"},{"location":"#in-code","title":"In Code","text":"<p>We'll first define our problem (dynamics, barrier, and any additional parameters) in a <code>CBFConfig</code>-derived class. </p> <p>We use Jax for fast compilation of the problem. Jax can be tricky to learn at first, but luckily <code>cbfpy</code> just requires formulating your functions in <code>jax.numpy</code> which has the same familiar interface as <code>numpy</code>. These should be pure functions without side effects (for instance, modifying a class variable in <code>self</code>).</p> <p>Additional tuning parameters/functions can be found in the <code>CBFConfig</code> documentation. </p> <p><pre><code>import jax.numpy as jnp\nfrom cbfpy import CBF, CBFConfig\n\n# Create a config class for your problem inheriting from the CBFConfig class\nclass MyCBFConfig(CBFConfig):\n    def __init__(self):\n        super().__init__(\n            # Define the state and control dimensions\n            n = 2, # [x, x_dot]\n            m = 1, # [F_x]\n            # Define control limits (if desired)\n            u_min = None,\n            u_max = None,\n        )\n\n    # Define the control-affine dynamics functions `f` and `g` for your system\n    def f(self, z):\n        A = jnp.array([[0.0, 1.0], [0.0, 0.0]])\n        return A @ z\n\n    def g(self, z):\n        mass = 1.0\n        B = jnp.array([[0.0], [1.0 / mass]])\n        return B\n\n    # Define the barrier function `h`\n    # The *relative degree* of this system is 2, so, we'll use the h_2 method\n    def h_2(self, z):\n        x_min = 1.0\n        x = z[0]\n        return jnp.array([x - x_min])\n</code></pre> We can then construct the CBF from our config and use it in our control loop as follows. <pre><code>config = MyCBFConfig()\ncbf = CBF.from_config(config)\n\n# Pseudocode\nwhile True:\n    z = get_state()\n    z_des = get_desired_state()\n    u_nom = nominal_controller(z, z_des)\n    u = cbf.safety_filter(z, u_nom)\n    apply_control(u)\n    step() \n</code></pre></p>"},{"location":"#examples","title":"Examples","text":"<p>These can be found in the <code>examples</code> folder here</p>"},{"location":"#adaptive-cruise-control","title":"Adaptive Cruise Control","text":"<p>Use a CLF-CBF to maintain a safe follow distance to the vehicle in front, while tracking a desired velocity</p> <ul> <li>State: z = [Follower velocity, Leader velocity, Follow distance] (n = 3)</li> <li>Control: u = [Follower wheel force] (m = 1)</li> <li>Relative degree: 1</li> </ul> <p></p>"},{"location":"#point-robot-safe-set-containment","title":"Point Robot Safe-Set Containment","text":"<p>Use a CBF to enforce that a point robot stays within a safe box, while a PD controller attempts to reduce the distance to a target position</p> <ul> <li>State: z = [Position, Velocity] (n = 6)</li> <li>Control: u = [Force] (m = 3)</li> <li>Relative degree: 2</li> </ul> <p></p>"},{"location":"#point-robot-obstacle-avoidance","title":"Point Robot Obstacle Avoidance","text":"<p>Use a CBF to keep a point robot inside a safe box, while avoiding a moving obstacle. The nominal PD controller attempts to keep the robot at the origin.</p> <ul> <li>State: z = [Position, Velocity] (n = 6)</li> <li>Control: u = [Force] (m = 3)</li> <li>Relative degree: 1 + 2 (1 for obstacle avoidance, 2 for safe set containment)</li> <li>Additional data: The state of the obstacle (position and velocity)</li> </ul> <p></p>"},{"location":"#manipulator-joint-limit-avoidance","title":"Manipulator Joint Limit Avoidance","text":"<p>Use a CBF to keep a manipulator operating within its joint limits, even if a nominal joint trajectory is unsafe. </p> <ul> <li>State: z = [Joint angles] (n = 3)</li> <li>Control: u = [Joint velocities] (m = 3)</li> <li>Relative degree: 1</li> </ul> <p></p>"},{"location":"#drone-obstacle-avoidance","title":"Drone Obstacle Avoidance","text":"<p>Use a CBF to keep a drone inside a safe box, while avoiding a moving obstacle. This is similar to the \"point robot obstacle avoidance\" demo, but with slightly different dynamics.</p> <ul> <li>State: z = [Position, Velocity] (n = 6)</li> <li>Control: u = [Velocity] (m = 3)</li> <li>Relative degree: 1</li> <li>Additional data: The state of the obstacle (position and velocity)</li> </ul> <p>This is the same CBF which was used in the \"Drone Fencing\" demo at the Stanford Robotics center.</p> <p></p>"},{"location":"pyenv/","title":"Installing Pyenv","text":"<p>This is a quick summary of how to get started with Pyenv and Python version/environment management. See the Pyenv Github for more details.</p> <p>Other environment managers like <code>conda</code> will also work, if preferred.</p>"},{"location":"pyenv/#install-dependencies","title":"Install dependencies:","text":"<pre><code>sudo apt-get update; sudo apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre>"},{"location":"pyenv/#install-pyenv","title":"Install Pyenv","text":"<pre><code>curl https://pyenv.run | bash\n</code></pre>"},{"location":"pyenv/#set-up-your-bashrc","title":"Set up your <code>~/.bashrc</code>","text":"<p>Check that the following lines below are included in the file. If not, paste them in. <pre><code>export PYENV_ROOT=\"$HOME/.pyenv\"\ncommand -v pyenv &gt;/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"\neval \"$(pyenv init -)\"\neval \"$(pyenv virtualenv-init -)\"\n</code></pre></p>"},{"location":"pyenv/#activate-your-environment","title":"Activate your environment","text":"<p>This repo was tested using Python <code>3.10.8</code>, however, Pyenv supports most Python versions (run <code>pyenv install -l | grep '^  [0-9]'</code> to see what is available to install). If another Python version is desired, replace <code>3.10.8</code> in the code below with your version.</p> <p>If you have not previously installed Python with Pyenv, run <pre><code>pyenv install 3.10.8\n</code></pre> Then, the following lines will create the environment and activate it for the current shell session. <pre><code>pyenv virtualenv 3.10.8 cbfpy\npyenv shell cbfpy\n</code></pre></p> <p>Tip</p> <p>Use <code>pyenv local cbfpy</code> in the top-level <code>cbfpy</code> directory to automatically switch to this environment when working in this directory.</p>"},{"location":"api/acc_demo/","title":"Adaptive Cruise Control","text":""},{"location":"api/acc_demo/#cbfpy.examples.adaptive_cruise_control_demo","title":"<code>cbfpy.examples.adaptive_cruise_control_demo</code>","text":""},{"location":"api/acc_demo/#cbfpy.examples.adaptive_cruise_control_demo--adaptive-cruise-control-clf-cbf-demo","title":"Adaptive Cruise Control CLF-CBF Demo","text":"<p>This will enforce that the follower vehicle maintains a safe distance from the leader vehicle, while also tracking a desired velocity.</p> <p>We define the state z as [v_follower, v_leader, follow_distance] and the control u as the follower's wheel force</p> <p>The dynamics incorporate a simple drag force model using empirically-derived coefficients</p> <p>Note: There are a few parameters to tune in this CLF-CBF, such as the weightings between the inputs the slack variable in the CLF objective. This is tricky to tune in general and values have been left at what has been seen in other references.</p> <p>Reference:</p> <ul> <li>\"Control Barrier Function Based Quadratic Programs for Safety Critical Systems\" - TAC 2017</li> <li>\"Control Barrier Function based Quadratic Programs with Application to Adaptive Cruise Control\" - CDC 2014</li> </ul> <p>Some parameters are based on Jason Choi's https://github.com/HybridRobotics/CBF-CLF-Helper</p>"},{"location":"api/acc_demo/#cbfpy.examples.adaptive_cruise_control_demo.ACCConfig","title":"<code>ACCConfig</code>","text":"<p>               Bases: <code>CLFCBFConfig</code></p> <p>Configuration for the Adaptive Cruise Control CLF-CBF demo</p> Source code in <code>cbfpy/examples/adaptive_cruise_control_demo.py</code> <pre><code>class ACCConfig(CLFCBFConfig):\n    \"\"\"Configuration for the Adaptive Cruise Control CLF-CBF demo\"\"\"\n\n    def __init__(self):\n        self.gravity = 9.81\n        self.mass = 1650.0\n        self.drag_coeffs = (0.1, 5.0, 0.25)  # Drag coeffs\n        self.v_des = 24.0  # Desired velocity\n        self.T = 1.8  # Lookahead time\n        self.cd = 0.3  # Coefficient of maximum deceleration\n        self.ca = 0.3  # Coefficient of maximum acceleration\n        u_min = -self.cd * self.mass * self.gravity  # Min. control input (max braking)\n        u_max = self.ca * self.mass * self.gravity  # Max. control input (max throttle)\n        super().__init__(\n            n=3,\n            m=1,\n            u_min=u_min,\n            u_max=u_max,\n            # Note: Relaxing the CLF-CBF QP is tricky because there is an additional relaxation\n            # parameter already, balancing the CLF and CBF constraints.\n            relax_qp=False,\n            # If indeed relaxing, ensure that the CBF relaxation &gt;&gt; the CLF relaxation\n            clf_relaxation_penalty=10.0,\n            cbf_relaxation_penalty=1e5,\n            control_relaxation_penalty=1e6,\n        )\n\n    def drag_force(self, v: float) -&gt; float:\n        \"\"\"Compute the drag force on the follower car using a simple polynomial model\n\n        Args:\n            v (float): Velocity of the follower vehicle, in m/s\n\n        Returns:\n            float: Drag force, in Newtons\n        \"\"\"\n        return (\n            self.drag_coeffs[0] + self.drag_coeffs[1] * v + self.drag_coeffs[2] * v**2\n        )\n\n    def f(self, z: ArrayLike) -&gt; Array:\n        v_f, v_l, D = z\n        # Note: We assume that the leader vehicle is at constant velocity here\n        return jnp.array([-self.drag_force(v_f) / self.mass, 0.0, v_l - v_f])\n\n    def g(self, z: ArrayLike) -&gt; Array:\n        return jnp.array([(1 / self.mass), 0.0, 0.0]).reshape(-1, 1)\n\n    def h_1(self, z: ArrayLike) -&gt; Array:\n        v_f, v_l, D = z\n        return jnp.array(\n            [D - self.T * v_f - 0.5 * (v_l - v_f) ** 2 / (self.cd * self.gravity)]\n        )\n\n    def V_1(self, z: ArrayLike, z_des: ArrayLike) -&gt; float:\n        # CLF: Squared error between the follower velocity and the desired velocity\n        return jnp.array([(z[0] - self.v_des) ** 2])\n\n    def H(self, z: ArrayLike) -&gt; Array:\n        return jnp.eye(self.m) * (2 / self.mass**2)\n\n    def F(self, z: ArrayLike) -&gt; Array:\n        return jnp.array([-2 * self.drag_force(z[0]) / self.mass**2])\n</code></pre>"},{"location":"api/acc_demo/#cbfpy.examples.adaptive_cruise_control_demo.ACCConfig.drag_force","title":"<code>drag_force(v)</code>","text":"<p>Compute the drag force on the follower car using a simple polynomial model</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>Velocity of the follower vehicle, in m/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Drag force, in Newtons</p> Source code in <code>cbfpy/examples/adaptive_cruise_control_demo.py</code> <pre><code>def drag_force(self, v: float) -&gt; float:\n    \"\"\"Compute the drag force on the follower car using a simple polynomial model\n\n    Args:\n        v (float): Velocity of the follower vehicle, in m/s\n\n    Returns:\n        float: Drag force, in Newtons\n    \"\"\"\n    return (\n        self.drag_coeffs[0] + self.drag_coeffs[1] * v + self.drag_coeffs[2] * v**2\n    )\n</code></pre>"},{"location":"api/arm_envs/","title":"Manipulator Envs","text":""},{"location":"api/arm_envs/#cbfpy.envs.arm_envs","title":"<code>cbfpy.envs.arm_envs</code>","text":""},{"location":"api/arm_envs/#cbfpy.envs.arm_envs--simulation-environents-for-robot-arms","title":"Simulation environents for robot arms","text":"<p>This currently includes a very simple 3-DOF environment which helps demonstrate joint limit avoidance, but more will be added in the future</p>"},{"location":"api/arm_envs/#cbfpy.envs.arm_envs.JointLimitsEnv","title":"<code>JointLimitsEnv</code>","text":"<p>               Bases: <code>BaseEnv</code></p> <p>Simulation environment for the 3-DOF arm joint-limit-avoidance demo</p> <p>This includes a desired reference trajectory which is unsafe: it will command sinusoidal joint motions (with different frequencies per link) that will exceed the joint limits of the robot</p> Source code in <code>cbfpy/envs/arm_envs.py</code> <pre><code>class JointLimitsEnv(BaseEnv):\n    \"\"\"Simulation environment for the 3-DOF arm joint-limit-avoidance demo\n\n    This includes a desired reference trajectory which is unsafe: it will command sinusoidal\n    joint motions (with different frequencies per link) that will exceed the joint limits of the robot\n    \"\"\"\n\n    def __init__(self):\n        with stdout_redirected(restore=False):\n            self.client: pybullet = BulletClient(pybullet.GUI)\n        self.robot = pybullet.loadURDF(URDF, useFixedBase=True)\n        self.num_joints = self.client.getNumJoints(self.robot)\n        self.q_min = np.array(\n            [self.client.getJointInfo(self.robot, i)[8] for i in range(self.num_joints)]\n        )\n        self.q_max = np.array(\n            [self.client.getJointInfo(self.robot, i)[9] for i in range(self.num_joints)]\n        )\n        self.timestep = self.client.getPhysicsEngineParameters()[\"fixedTimeStep\"]\n        self.t = 0\n\n        # Sinusoids for the desired joint positions\n        # Setting the amplitude to be the full joint range means we will command DOUBLE\n        # the joint range, exceeding our limits\n        self.omegas = 0.1 * np.array([1.0, 2.0, 3.0])\n        self.amps = self.q_max - self.q_min\n        self.offsets = np.zeros(3)\n\n    def step(self):\n        self.client.stepSimulation()\n        self.t += self.timestep\n\n    def get_state(self):\n        states = self.client.getJointStates(self.robot, range(self.num_joints))\n        return np.array([states[i][0] for i in range(self.num_joints)])\n\n    def get_desired_state(self):\n        # Evaluate our unsafe sinusoidal trajectory\n        return self.amps * np.sin(self.omegas * self.t) + self.offsets\n\n    def apply_control(self, u):\n        self.client.setJointMotorControlArray(\n            self.robot,\n            list(range(self.num_joints)),\n            self.client.VELOCITY_CONTROL,\n            targetVelocities=u,\n        )\n</code></pre>"},{"location":"api/base_env/","title":"Base Env","text":""},{"location":"api/base_env/#cbfpy.envs.base_env","title":"<code>cbfpy.envs.base_env</code>","text":""},{"location":"api/base_env/#cbfpy.envs.base_env--base-environment","title":"Base Environment","text":"<p>This is a convenient structure for building demo environments to test CBFs. However, it is not necessary to use this.</p> <p>For instance, going back to the CBF usage pseudocode, <pre><code>while True:\n    z = get_state()\n    z_des = get_desired_state()\n    u_nom = nominal_controller(z, z_des)\n    u = cbf.safety_filter(z, u_nom)\n    apply_control(u)\n    step()\n</code></pre> We use this base environment to set up the <code>get_state</code>, <code>get_desired_state</code>, <code>apply_control</code>, and <code>step</code> methods in any derived environments.</p>"},{"location":"api/base_env/#cbfpy.envs.base_env.BaseEnv","title":"<code>BaseEnv</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Simulation environment Abstract Base Class for testing CBFs</p> <p>Any environment inheriting from this class should implement the following methods:</p> <ul> <li><code>step</code>: Run a single simulation step</li> <li><code>get_state</code>: Get the current state of the robot</li> <li><code>get_desired_state</code>: Get the desired state of the robot</li> <li><code>apply_control</code>: Apply a control input to the robot</li> </ul> Source code in <code>cbfpy/envs/base_env.py</code> <pre><code>class BaseEnv(ABC):\n    \"\"\"Simulation environment Abstract Base Class for testing CBFs\n\n    Any environment inheriting from this class should implement the following methods:\n\n    - `step`: Run a single simulation step\n    - `get_state`: Get the current state of the robot\n    - `get_desired_state`: Get the desired state of the robot\n    - `apply_control`: Apply a control input to the robot\n    \"\"\"\n\n    @abstractmethod\n    def step(self) -&gt; None:\n        \"\"\"Runs a single simulation step for the environment\n\n        This should update any dynamics and visuals\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_state(self) -&gt; ArrayLike:\n        \"\"\"Returns the current state of the environment\n\n        Returns:\n            ArrayLike: State, shape (n,)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_desired_state(self) -&gt; ArrayLike:\n        \"\"\"Returns the desired state of the environment\n\n        Returns:\n            ArrayLike: Desired state, shape (n,)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def apply_control(self, u: ArrayLike) -&gt; None:\n        \"\"\"Applies the control input to the environment\n\n        Args:\n            u (ArrayLike): Control, shape (m,)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/base_env/#cbfpy.envs.base_env.BaseEnv.step","title":"<code>step()</code>  <code>abstractmethod</code>","text":"<p>Runs a single simulation step for the environment</p> <p>This should update any dynamics and visuals</p> Source code in <code>cbfpy/envs/base_env.py</code> <pre><code>@abstractmethod\ndef step(self) -&gt; None:\n    \"\"\"Runs a single simulation step for the environment\n\n    This should update any dynamics and visuals\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/base_env/#cbfpy.envs.base_env.BaseEnv.get_state","title":"<code>get_state()</code>  <code>abstractmethod</code>","text":"<p>Returns the current state of the environment</p> <p>Returns:</p> Name Type Description <code>ArrayLike</code> <code>ArrayLike</code> <p>State, shape (n,)</p> Source code in <code>cbfpy/envs/base_env.py</code> <pre><code>@abstractmethod\ndef get_state(self) -&gt; ArrayLike:\n    \"\"\"Returns the current state of the environment\n\n    Returns:\n        ArrayLike: State, shape (n,)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/base_env/#cbfpy.envs.base_env.BaseEnv.get_desired_state","title":"<code>get_desired_state()</code>  <code>abstractmethod</code>","text":"<p>Returns the desired state of the environment</p> <p>Returns:</p> Name Type Description <code>ArrayLike</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> Source code in <code>cbfpy/envs/base_env.py</code> <pre><code>@abstractmethod\ndef get_desired_state(self) -&gt; ArrayLike:\n    \"\"\"Returns the desired state of the environment\n\n    Returns:\n        ArrayLike: Desired state, shape (n,)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/base_env/#cbfpy.envs.base_env.BaseEnv.apply_control","title":"<code>apply_control(u)</code>  <code>abstractmethod</code>","text":"<p>Applies the control input to the environment</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ArrayLike</code> <p>Control, shape (m,)</p> required Source code in <code>cbfpy/envs/base_env.py</code> <pre><code>@abstractmethod\ndef apply_control(self, u: ArrayLike) -&gt; None:\n    \"\"\"Applies the control input to the environment\n\n    Args:\n        u (ArrayLike): Control, shape (m,)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/car_env/","title":"Cruise Control Env","text":""},{"location":"api/car_env/#cbfpy.envs.car_env","title":"<code>cbfpy.envs.car_env</code>","text":""},{"location":"api/car_env/#cbfpy.envs.car_env--adaptive-cruise-control-simulation-environment","title":"Adaptive Cruise Control Simulation Environment","text":"<p>Simple simulation of a leader-follower vehicle system for adaptive cruise control testing</p>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv","title":"<code>VehicleEnv</code>","text":"<p>               Bases: <code>BaseEnv</code></p> <p>Leader/follower vehicle simulation environment for adaptive cruise control testing</p> <p>This will bring up an interactive Pygame window where you can control the speed of the leader car, and the follower car will be controlled by a simple adaptive cruise control algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>controller_name</code> <code>str</code> <p>Name of the controller being tested</p> required <code>mass</code> <code>float</code> <p>Mass of the follower vehicle. Defaults to 1650.0 (kg)</p> <code>1650.0</code> <code>drag_coeffs</code> <code>Tuple[float, float, float]</code> <p>Coefficients of a simple polynomial friction model, as described in the Ames CBF paper. Defaults to (0.1, 5.0, 0.25)</p> <code>(0.1, 5.0, 0.25)</code> <code>v_des</code> <code>float</code> <p>Desired velocity of the follower car. Defaults to 24.0 (m/s)</p> <code>24.0</code> <code>init_leader_pos</code> <code>float</code> <p>Initial position of the leader car. Defaults to 0.0 (meters)</p> <code>0.0</code> <code>init_leader_vel</code> <code>float</code> <p>Initial velocity of the leader car. Defaults to 14.0 (m/s)</p> <code>14.0</code> <code>init_follower_pos</code> <code>float</code> <p>Initial position of the follower car. Defaults to -20.0 (meters)</p> <code>-20.0</code> <code>init_follower_vel</code> <code>float</code> <p>Initial velocity of the follower car. Defaults to 10.0 (m/s)</p> <code>10.0</code> <code>u_min</code> <code>float</code> <p>Minimum control input, in Newtons. Defaults to -np.inf (unconstrained)</p> <code>-inf</code> <code>u_max</code> <code>float</code> <p>Maximum control input, in Newtons. Defaults to np.inf (unconstrained)</p> <code>inf</code> Source code in <code>cbfpy/envs/car_env.py</code> <pre><code>class VehicleEnv(BaseEnv):\n    \"\"\"Leader/follower vehicle simulation environment for adaptive cruise control testing\n\n    This will bring up an interactive Pygame window where you can control the speed of the leader car,\n    and the follower car will be controlled by a simple adaptive cruise control algorithm.\n\n    Args:\n        controller_name (str): Name of the controller being tested\n        mass (float, optional): Mass of the follower vehicle. Defaults to 1650.0 (kg)\n        drag_coeffs (Tuple[float, float, float]): Coefficients of a simple polynomial friction model, as\n            described in the Ames CBF paper. Defaults to (0.1, 5.0, 0.25)\n        v_des (float, optional): Desired velocity of the follower car. Defaults to 24.0 (m/s)\n        init_leader_pos (float, optional): Initial position of the leader car. Defaults to 0.0 (meters)\n        init_leader_vel (float, optional): Initial velocity of the leader car. Defaults to 14.0 (m/s)\n        init_follower_pos (float, optional): Initial position of the follower car. Defaults to -20.0 (meters)\n        init_follower_vel (float, optional): Initial velocity of the follower car. Defaults to 10.0 (m/s)\n        u_min (float, optional): Minimum control input, in Newtons. Defaults to -np.inf (unconstrained)\n        u_max (float, optional): Maximum control input, in Newtons. Defaults to np.inf (unconstrained)\n    \"\"\"\n\n    # Constants\n    PIXELS_PER_METER = 15\n    MIN_FOLLOW_DIST_M = 1\n    MIN_FOLLOW_DIST_PX = PIXELS_PER_METER * MIN_FOLLOW_DIST_M\n\n    # Screen dimensions\n    SCREEN_WIDTH = 600\n    SCREEN_HEIGHT = 800\n\n    # Colors\n    WHITE = (255, 255, 255)\n    GRAY = (100, 100, 100)\n    BLACK = (0, 0, 0)\n    BLUE = (0, 0, 255)\n    RED = (255, 0, 0)\n    YELLOW = (255, 255, 0)\n\n    # Road properties\n    DASH_HEIGHT_M = 2\n    DASH_WIDTH_M = 0.3\n    DASH_GAP_M = 1\n    DASH_HEIGHT_PX = PIXELS_PER_METER * DASH_HEIGHT_M\n    DASH_WIDTH_PX = PIXELS_PER_METER * DASH_WIDTH_M\n    DASH_GAP_PX = PIXELS_PER_METER * DASH_GAP_M\n\n    # Car properties\n    CAR_WIDTH_M = 2\n    CAR_HEIGHT_M = 4\n    CAR_WIDTH_PX = PIXELS_PER_METER * CAR_WIDTH_M\n    CAR_HEIGHT_PX = PIXELS_PER_METER * CAR_HEIGHT_M\n\n    def __init__(\n        self,\n        controller_name: str,\n        mass: float = 1650.0,\n        drag_coeffs: Tuple[float, float, float] = (0.1, 5.0, 0.25),\n        v_des: float = 24.0,\n        init_leader_pos: float = 0.0,\n        init_leader_vel: float = 14.0,\n        init_follower_pos: float = -20.0,\n        init_follower_vel: float = 10.0,\n        u_min: float = -np.inf,\n        u_max: float = np.inf,\n    ):\n        self.mass = mass\n        self.v_des = v_des  # Desired velocity of the follower car\n        assert len(drag_coeffs) == 3\n        self.f0, self.f1, self.f2 = drag_coeffs\n        # Initialize Pygame\n        pygame.init()\n        # Set up the display\n        self.screen = pygame.display.set_mode(\n            (VehicleEnv.SCREEN_WIDTH, VehicleEnv.SCREEN_HEIGHT)\n        )\n        pygame.display.set_caption(f\"Adaptive Cruise Control: {controller_name}\")\n        # Create car sprites\n        self.leader_sprite = pygame.Surface(\n            (VehicleEnv.CAR_WIDTH_PX, VehicleEnv.CAR_HEIGHT_PX)\n        )\n        self.leader_sprite.fill(VehicleEnv.RED)\n        self.follower_sprite = pygame.Surface(\n            (VehicleEnv.CAR_WIDTH_PX, VehicleEnv.CAR_HEIGHT_PX)\n        )\n        self.follower_sprite.fill(VehicleEnv.BLUE)\n        # Positioning the cars in the display\n        self.leader_x = int(VehicleEnv.SCREEN_WIDTH / 4 - VehicleEnv.CAR_WIDTH_PX / 2)\n        self.leader_y = VehicleEnv.SCREEN_HEIGHT // 5\n        self.follower_x = self.leader_x\n        self.follower_y = self.leader_y + VehicleEnv.MIN_FOLLOW_DIST_PX\n\n        # Init dynamics\n        self.leader_pos = init_leader_pos\n        self.leader_vel = init_leader_vel\n        self.follower_pos = init_follower_pos\n        self.follower_vel = init_follower_vel\n\n        self.leader_vel_des = init_leader_vel\n\n        # Initial position of dashed lines\n        self.dash_offset = 0\n\n        self.font = pygame.font.SysFont(\"Arial\", 20)\n\n        self.fps = 60\n        self.dt = 1 / self.fps\n        self.running = True\n\n        self.last_control = 0.0\n\n        self.u_min = u_min\n        self.u_max = u_max\n\n        # Print instructions\n        print(CAR_ASCII)\n        print(\"Beginning Vehicle Simulation\")\n        print(\"Press UP and DOWN to control the speed of the leader car\")\n        print(\"Press ESC to quit\")\n\n    def pixels_to_meters(self, n_pixels: int) -&gt; float:\n        \"\"\"Helper function: Converts pixels to meters\n\n        Args:\n            n_pixels (int): Number of pixels\n\n        Returns:\n            float: Distance in meters\n        \"\"\"\n        return n_pixels / self.PIXELS_PER_METER\n\n    def meters_to_pixels(self, n_meters: float) -&gt; float:\n        \"\"\"Helper function: Converts meters to pixels\n\n        Args:\n            n_meters (float): Distance in meters\n\n        Returns:\n            float: Number of pixels (Note: Not rounded to an integer value)\n        \"\"\"\n        return n_meters * self.PIXELS_PER_METER\n\n    def friction(self, v: float) -&gt; float:\n        \"\"\"Computes the drag force on the vehicle with the simple model presented in the Ames CBF paper\n\n        Args:\n            v (float): Car speed, in m/s\n\n        Returns:\n            float: Drag force on the car, in Newtons\n        \"\"\"\n        return self.f0 + self.f1 * v + self.f2 * v**2\n\n    @property\n    def follow_distance(self):\n        \"\"\"Distance between the leader and follower cars, in meters\"\"\"\n        return self.leader_pos - self.follower_pos - self.CAR_HEIGHT_M\n\n    def get_state(self):\n        return np.array(\n            [\n                self.follower_vel,\n                self.leader_vel,\n                self.follow_distance,\n            ]\n        )\n\n    def get_desired_state(self):\n        leader_speed_kmh = 3.6 * self.leader_vel\n        safe_follow_distance = leader_speed_kmh / 2 + self.MIN_FOLLOW_DIST_M\n        # Note: This desired state is primarily for the simple nominal controller and NOT the CLF-CBF\n        return np.array(\n            [\n                self.v_des,\n                self.leader_vel,\n                safe_follow_distance,\n            ]\n        )\n\n    def apply_control(self, u) -&gt; None:\n        u = np.clip(u, self.u_min, self.u_max).item()\n        if np.isnan(u):\n            print(\"Infeasible. Using last safe control\")\n            u = self.last_control\n        force = u - self.friction(self.follower_vel)\n        follower_accel = force / self.mass\n        self.follower_vel += follower_accel * self.dt\n        self.follower_pos += self.follower_vel * self.dt\n        self.last_control = u\n\n    def leader_controller(self) -&gt; float:\n        \"\"\"Simple controller for the leader car\n\n        The desired leader velocity will be set by the user, and this controller will try to track that velocity\n\n        Returns:\n            float: Control input to the leader car: Acceleration force, in Newtons\n        \"\"\"\n        kv = 1000\n        return kv * (self.leader_vel_des - self.leader_vel)\n\n    def step(self):\n        # Handle events\n        # This includes where the speed of the main controlled by the user\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.running = False\n                return\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    self.leader_vel_des += 1\n                elif event.key == pygame.K_DOWN:\n                    self.leader_vel_des -= 1\n                elif event.key == pygame.K_ESCAPE:\n                    self.running = False\n                    return\n\n        leader_u = self.leader_controller()\n        leader_force = leader_u - self.friction(self.leader_vel)\n        # Assume both vehicles have the same mass\n        leader_accel = leader_force / self.mass\n        self.leader_vel += leader_accel * self.dt\n        self.leader_pos += self.leader_vel * self.dt\n        follow_dist = self.follow_distance\n\n        # Update locations of the cars in pixel frame\n        self.follower_y = (\n            self.leader_y + self.meters_to_pixels(follow_dist) + self.CAR_HEIGHT_PX\n        )\n\n        # Clear the screen\n        self.screen.fill(VehicleEnv.WHITE)\n\n        # Draw the road\n        pygame.draw.rect(\n            self.screen,\n            VehicleEnv.GRAY,\n            (\n                0,\n                0,\n                VehicleEnv.SCREEN_WIDTH // 2,\n                VehicleEnv.SCREEN_HEIGHT,\n            ),\n        )\n\n        # Draw dashed lines on the road\n        dash_y = self.dash_offset\n        while dash_y &lt; VehicleEnv.SCREEN_HEIGHT:\n            pygame.draw.rect(\n                self.screen,\n                VehicleEnv.YELLOW,\n                (\n                    VehicleEnv.SCREEN_WIDTH // 4 - VehicleEnv.DASH_WIDTH_PX // 2,\n                    dash_y,\n                    VehicleEnv.DASH_WIDTH_PX,\n                    VehicleEnv.DASH_HEIGHT_PX,\n                ),\n            )\n            dash_y += VehicleEnv.DASH_HEIGHT_PX + VehicleEnv.DASH_GAP_PX\n\n        # Move the dashed lines\n        self.dash_offset += self.leader_vel\n        if self.dash_offset &gt;= VehicleEnv.DASH_HEIGHT_PX + VehicleEnv.DASH_GAP_PX:\n            self.dash_offset = 0\n\n        # Draw the cars\n        self.screen.blit(self.leader_sprite, (self.leader_x, self.leader_y))\n        self.screen.blit(self.follower_sprite, (self.follower_x, self.follower_y))\n\n        # Print info to the pygame window\n        info_1 = f\"Leader desired speed: {self.leader_vel_des:.2f}\"\n        info_2 = f\"Leader speed: {self.leader_vel:.2f}\"\n        info_3 = f\"Follower speed: {self.follower_vel:.2f}\"\n        info_4 = f\"Follow distance: {follow_dist:.2f}\"\n        info_5 = f\"Control: {self.last_control:.2f}\"\n        text = [info_1, info_2, info_3, info_4, info_5]\n        for i, line in enumerate(text):\n            self.screen.blit(\n                self.font.render(line, True, VehicleEnv.BLACK),\n                (VehicleEnv.SCREEN_WIDTH // 2 + 10, 10 + 30 * i),\n            )\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        pygame.time.Clock().tick(self.fps)\n</code></pre>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv.follow_distance","title":"<code>follow_distance</code>  <code>property</code>","text":"<p>Distance between the leader and follower cars, in meters</p>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv.pixels_to_meters","title":"<code>pixels_to_meters(n_pixels)</code>","text":"<p>Helper function: Converts pixels to meters</p> <p>Parameters:</p> Name Type Description Default <code>n_pixels</code> <code>int</code> <p>Number of pixels</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Distance in meters</p> Source code in <code>cbfpy/envs/car_env.py</code> <pre><code>def pixels_to_meters(self, n_pixels: int) -&gt; float:\n    \"\"\"Helper function: Converts pixels to meters\n\n    Args:\n        n_pixels (int): Number of pixels\n\n    Returns:\n        float: Distance in meters\n    \"\"\"\n    return n_pixels / self.PIXELS_PER_METER\n</code></pre>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv.meters_to_pixels","title":"<code>meters_to_pixels(n_meters)</code>","text":"<p>Helper function: Converts meters to pixels</p> <p>Parameters:</p> Name Type Description Default <code>n_meters</code> <code>float</code> <p>Distance in meters</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Number of pixels (Note: Not rounded to an integer value)</p> Source code in <code>cbfpy/envs/car_env.py</code> <pre><code>def meters_to_pixels(self, n_meters: float) -&gt; float:\n    \"\"\"Helper function: Converts meters to pixels\n\n    Args:\n        n_meters (float): Distance in meters\n\n    Returns:\n        float: Number of pixels (Note: Not rounded to an integer value)\n    \"\"\"\n    return n_meters * self.PIXELS_PER_METER\n</code></pre>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv.friction","title":"<code>friction(v)</code>","text":"<p>Computes the drag force on the vehicle with the simple model presented in the Ames CBF paper</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>Car speed, in m/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Drag force on the car, in Newtons</p> Source code in <code>cbfpy/envs/car_env.py</code> <pre><code>def friction(self, v: float) -&gt; float:\n    \"\"\"Computes the drag force on the vehicle with the simple model presented in the Ames CBF paper\n\n    Args:\n        v (float): Car speed, in m/s\n\n    Returns:\n        float: Drag force on the car, in Newtons\n    \"\"\"\n    return self.f0 + self.f1 * v + self.f2 * v**2\n</code></pre>"},{"location":"api/car_env/#cbfpy.envs.car_env.VehicleEnv.leader_controller","title":"<code>leader_controller()</code>","text":"<p>Simple controller for the leader car</p> <p>The desired leader velocity will be set by the user, and this controller will try to track that velocity</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Control input to the leader car: Acceleration force, in Newtons</p> Source code in <code>cbfpy/envs/car_env.py</code> <pre><code>def leader_controller(self) -&gt; float:\n    \"\"\"Simple controller for the leader car\n\n    The desired leader velocity will be set by the user, and this controller will try to track that velocity\n\n    Returns:\n        float: Control input to the leader car: Acceleration force, in Newtons\n    \"\"\"\n    kv = 1000\n    return kv * (self.leader_vel_des - self.leader_vel)\n</code></pre>"},{"location":"api/cbf/","title":"CBF","text":""},{"location":"api/cbf/#cbfpy.cbfs.cbf--control-barrier-functions-cbfs","title":"Control Barrier Functions (CBFs)","text":"<p>CBFs serve as safety filters on top of a nominal controller. Given a nominal control input, the CBF will compute a safe control input to keep the system within a safe set.</p> <p>For a relative-degree-1 system, this optimizes the standard min-norm objective with the constraint <code>h_dot &gt;= -alpha(h(z))</code> <pre><code>minimize ||u - u_des||_{2}^{2}               # CBF Objective (Example)\nsubject to Lfh(z) + Lgh(z)u &gt;= -alpha(h(z))  # RD1 CBF Constraint\n</code></pre></p> <p>In the case of a relative-degree-2 system, this differs slightly to enforce the RD2 constraint <code>h_2_dot &gt;= -alpha_2(h_2(z))</code> <pre><code>minimize ||u - u_des||_{2}^{2}                       # CBF Objective (Example)\nsubject to Lfh_2(z) + Lgh_2(z)u &gt;= -alpha_2(h_2(z))  # RD2 CBF Constraint\n</code></pre></p> <p>If there are constraints on the control input, we also enforce another constraint: <pre><code>u_min &lt;= u &lt;= u_max  # Control constraint\n</code></pre></p>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF","title":"<code>CBF</code>","text":"<p>Control Barrier Function (CBF) class.</p> <p>The main constructor for this class is via the <code>from_config</code> method, which constructs a CBF instance based on the provided CBFConfig configuration object.</p> <p>You can then use the CBF's <code>safety_filter</code> method to compute the control input that satisfies the CBF</p> <p>Examples:</p> <pre><code># Construct a CBFConfig for your problem\nconfig = DroneConfig()\n# Construct a CBF instance based on the config\ncbf = CBF.from_config(config)\n# Compute the safe control input\nsafe_control = cbf.safety_filter(current_state, nominal_control)\n</code></pre> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>@jax.tree_util.register_static\nclass CBF:\n    \"\"\"Control Barrier Function (CBF) class.\n\n    The main constructor for this class is via the `from_config` method, which constructs a CBF instance\n    based on the provided CBFConfig configuration object.\n\n    You can then use the CBF's `safety_filter` method to compute the control input that satisfies the CBF\n\n    Examples:\n        ```\n        # Construct a CBFConfig for your problem\n        config = DroneConfig()\n        # Construct a CBF instance based on the config\n        cbf = CBF.from_config(config)\n        # Compute the safe control input\n        safe_control = cbf.safety_filter(current_state, nominal_control)\n        ```\n    \"\"\"\n\n    # NOTE: The __init__ method is not used to construct a CBF instance. Instead, use the `from_config` method.\n    # This is because Jax prefers for the __init__ method to not contain any input validation, so we do this\n    # in the CBFConfig class instead.\n    def __init__(\n        self,\n        n: int,\n        m: int,\n        num_cbf: int,\n        u_min: Optional[tuple],\n        u_max: Optional[tuple],\n        control_constrained: bool,\n        relax_qp: bool,\n        constraint_relaxation_penalties: tuple,\n        h_1: Callable[[ArrayLike], Array],\n        h_2: Callable[[ArrayLike], Array],\n        f: Callable[[ArrayLike], Array],\n        g: Callable[[ArrayLike], Array],\n        alpha: Callable[[ArrayLike], Array],\n        alpha_2: Callable[[ArrayLike], Array],\n        P: Callable[[ArrayLike, ArrayLike, Tuple[ArrayLike, ...]], Array],\n        q: Callable[[ArrayLike, ArrayLike, Tuple[ArrayLike, ...]], Array],\n        solver_tol: float,\n    ):\n        self.n = n\n        self.m = m\n        self.num_cbf = num_cbf\n        self.u_min = u_min\n        self.u_max = u_max\n        self.control_constrained = control_constrained\n        self.relax_qp = relax_qp\n        self.constraint_relaxation_penalties = constraint_relaxation_penalties\n        self.h_1 = h_1\n        self.h_2 = h_2\n        self.f = f\n        self.g = g\n        self.alpha = alpha\n        self.alpha_2 = alpha_2\n        self.P_config = P\n        self.q_config = q\n        self.solver_tol = solver_tol\n\n    @classmethod\n    def from_config(cls, config: CBFConfig) -&gt; \"CBF\":\n        \"\"\"Construct a CBF based on the provided configuration\n\n        Args:\n            config (CBFConfig): Config object for the CBF. Contains info on the system dynamics, barrier function, etc.\n\n        Returns:\n            CBF: Control Barrier Function instance\n        \"\"\"\n        instance = cls(\n            config.n,\n            config.m,\n            config.num_cbf,\n            config.u_min,\n            config.u_max,\n            config.control_constrained,\n            config.relax_qp,\n            config.constraint_relaxation_penalties,\n            config.h_1,\n            config.h_2,\n            config.f,\n            config.g,\n            config.alpha,\n            config.alpha_2,\n            config.P,\n            config.q,\n            config.solver_tol,\n        )\n        instance._validate_instance(*config.init_args)\n        return instance\n\n    def _validate_instance(self, *h_args) -&gt; None:\n        \"\"\"Checks that the CBF is valid; warns the user if not\n\n        Args:\n            *h_args: Optional additional arguments for the barrier function.\n        \"\"\"\n        try:\n            # TODO: Decide if this should be checked on a row-by-row basis or via the full matrix\n            test_lgh = self.Lgh(jnp.ones(self.n), *h_args)\n            if jnp.allclose(test_lgh, 0):\n                print_warning(\n                    \"Lgh is zero. Consider increasing the relative degree or modifying the barrier function.\"\n                )\n        except TypeError:\n            print_warning(\n                \"Cannot test Lgh; missing additional arguments.\\n\"\n                + \"Please provide an initial seed for these args in the config's init_args input\"\n            )\n\n    @jax.jit\n    def safety_filter(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n        \"\"\"Apply the CBF safety filter to a nominal control\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Safe control input, shape (m,)\n        \"\"\"\n        P, q, A, b, G, h = self.qp_data(z, u_des, *h_args)\n        if self.relax_qp:\n            x_qp = qpax.solve_qp_elastic_primal(\n                P,\n                q,\n                G,\n                h,\n                penalty=jnp.asarray(self.constraint_relaxation_penalties),\n                solver_tol=self.solver_tol,\n            )\n        else:\n            x_qp, s_qp, z_qp, y_qp, converged, iters = qpax.solve_qp(\n                P,\n                q,\n                A,\n                b,\n                G,\n                h,\n                solver_tol=self.solver_tol,\n            )\n        return x_qp[: self.m]\n\n    def h(self, z: ArrayLike, *h_args) -&gt; Array:\n        \"\"\"Barrier function(s)\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Barrier function evaluation, shape (num_barr,)\n        \"\"\"\n\n        # Take any relative-degree-2 barrier functions and convert them to relative-degree-1\n        def _h_2(state):\n            return self.h_2(state, *h_args)\n\n        h_2, dh_2_dt = jax.jvp(_h_2, (z,), (self.f(z),))\n        h_2_as_rd1 = dh_2_dt + self.alpha_2(h_2)\n\n        # Merge the relative-degree-1 and relative-degree-2 barrier functions\n        return jnp.concatenate([self.h_1(z, *h_args), h_2_as_rd1])\n\n    def h_and_Lfh(  # pylint: disable=invalid-name\n        self, z: ArrayLike, *h_args\n    ) -&gt; Tuple[Array, Array]:\n        \"\"\"Lie derivative of the barrier function(s) wrt the autonomous dynamics `f(z)`\n\n        The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            h (Array): Barrier function evaluation, shape (num_barr,)\n            Lfh (Array): Lie derivative of `h` w.r.t. `f`, shape (num_barr,)\n        \"\"\"\n        # Note: the below code is just a more efficient way of stating `Lfh = jax.jacobian(self.h)(z) @ self.f(z)`\n        # with the bonus benefit of also evaluating the barrier function\n\n        def _h(state):\n            return self.h(state, *h_args)\n\n        return jax.jvp(_h, (z,), (self.f(z),))\n\n    def Lgh(self, z: ArrayLike, *h_args) -&gt; Array:  # pylint: disable=invalid-name\n        \"\"\"Lie derivative of the barrier function(s) wrt the control dynamics `g(z)u`\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Lgh, shape (num_barr, m)\n        \"\"\"\n        # Note: the below code is just a more efficient way of stating `Lgh = jax.jacobian(self.h)(z) @ self.g(z)`\n\n        def _h(state):\n            return self.h(state, *h_args)\n\n        def _jvp(g_column):\n            return jax.jvp(_h, (z,), (g_column,))[1]\n\n        return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n\n    ## QP Matrices ##\n\n    def P_qp(  # pylint: disable=invalid-name\n        self, z: Array, u_des: Array, *h_args\n    ) -&gt; Array:\n        \"\"\"Quadratic term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: P matrix, shape (m, m)\n        \"\"\"\n        # This is user-modifiable in the config, but defaults to 2 * I for the standard min-norm CBF objective\n        return self.P_config(z, u_des, *h_args)\n\n    def q_qp(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n        \"\"\"Linear term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: q vector, shape (m,)\n        \"\"\"\n        # This is user-modifiable in the config, but defaults to -2 * u_des for the standard min-norm CBF objective\n        return self.q_config(z, u_des, *h_args)\n\n    def G_qp(  # pylint: disable=invalid-name\n        self, z: Array, u_des: Array, *h_args\n    ) -&gt; Array:\n        \"\"\"Inequality constraint matrix for the QP (`Gx &lt;= h`)\n\n        Note:\n            The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: G matrix, shape (num_constraints, m)\n        \"\"\"\n        G = -self.Lgh(z, *h_args)\n        if self.control_constrained:\n            return jnp.block([[G], [jnp.eye(self.m)], [-jnp.eye(self.m)]])\n        else:\n            return G\n\n    def h_qp(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n        \"\"\"Upper bound on constraints for the QP (`Gx &lt;= h`)\n\n        Note:\n            The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: h vector, shape (num_constraints,)\n        \"\"\"\n        hz, lfh = self.h_and_Lfh(z, *h_args)\n        h = self.alpha(hz) + lfh\n        if self.control_constrained:\n            return jnp.concatenate(\n                [h, jnp.asarray(self.u_max), -jnp.asarray(self.u_min)]\n            )\n        else:\n            return h\n\n    def qp_data(\n        self, z: Array, u_des: Array, *h_args\n    ) -&gt; Tuple[Array, Array, Array, Array, Array, Array]:\n        \"\"\"Constructs the QP matrices based on the current state and desired control\n\n        i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:\n\n        ```\n        minimize 0.5 * x^T P x + q^T x\n        subject to  A x == b\n                    G x &lt;= h\n        ```\n\n        Note:\n            - CBFs do not rely on equality constraints, so `A` and `b` are empty.\n            - The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            P (Array): Quadratic term in the QP objective, shape (m, m)\n            q (Array): Linear term in the QP objective, shape (m,)\n            A (Array): Equality constraint matrix, shape (0, m)\n            b (Array): Equality constraint vector, shape (0,)\n            G (Array): Inequality constraint matrix, shape (num_constraints, m)\n            h (Array): Upper bound on constraints, shape (num_constraints,)\n        \"\"\"\n        return (\n            self.P_qp(z, u_des, *h_args),\n            self.q_qp(z, u_des, *h_args),\n            jnp.zeros((0, self.m)),  # Equality matrix (not used for CBF)\n            jnp.zeros(0),  # Equality vector (not used for CBF)\n            self.G_qp(z, u_des, *h_args),\n            self.h_qp(z, u_des, *h_args),\n        )\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.from_config","title":"<code>from_config(config)</code>  <code>classmethod</code>","text":"<p>Construct a CBF based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CBFConfig</code> <p>Config object for the CBF. Contains info on the system dynamics, barrier function, etc.</p> required <p>Returns:</p> Name Type Description <code>CBF</code> <code>CBF</code> <p>Control Barrier Function instance</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>@classmethod\ndef from_config(cls, config: CBFConfig) -&gt; \"CBF\":\n    \"\"\"Construct a CBF based on the provided configuration\n\n    Args:\n        config (CBFConfig): Config object for the CBF. Contains info on the system dynamics, barrier function, etc.\n\n    Returns:\n        CBF: Control Barrier Function instance\n    \"\"\"\n    instance = cls(\n        config.n,\n        config.m,\n        config.num_cbf,\n        config.u_min,\n        config.u_max,\n        config.control_constrained,\n        config.relax_qp,\n        config.constraint_relaxation_penalties,\n        config.h_1,\n        config.h_2,\n        config.f,\n        config.g,\n        config.alpha,\n        config.alpha_2,\n        config.P,\n        config.q,\n        config.solver_tol,\n    )\n    instance._validate_instance(*config.init_args)\n    return instance\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.safety_filter","title":"<code>safety_filter(z, u_des, *h_args)</code>","text":"<p>Apply the CBF safety filter to a nominal control</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Safe control input, shape (m,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>@jax.jit\ndef safety_filter(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Apply the CBF safety filter to a nominal control\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Safe control input, shape (m,)\n    \"\"\"\n    P, q, A, b, G, h = self.qp_data(z, u_des, *h_args)\n    if self.relax_qp:\n        x_qp = qpax.solve_qp_elastic_primal(\n            P,\n            q,\n            G,\n            h,\n            penalty=jnp.asarray(self.constraint_relaxation_penalties),\n            solver_tol=self.solver_tol,\n        )\n    else:\n        x_qp, s_qp, z_qp, y_qp, converged, iters = qpax.solve_qp(\n            P,\n            q,\n            A,\n            b,\n            G,\n            h,\n            solver_tol=self.solver_tol,\n        )\n    return x_qp[: self.m]\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.h","title":"<code>h(z, *h_args)</code>","text":"<p>Barrier function(s)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function evaluation, shape (num_barr,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def h(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Barrier function(s)\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Barrier function evaluation, shape (num_barr,)\n    \"\"\"\n\n    # Take any relative-degree-2 barrier functions and convert them to relative-degree-1\n    def _h_2(state):\n        return self.h_2(state, *h_args)\n\n    h_2, dh_2_dt = jax.jvp(_h_2, (z,), (self.f(z),))\n    h_2_as_rd1 = dh_2_dt + self.alpha_2(h_2)\n\n    # Merge the relative-degree-1 and relative-degree-2 barrier functions\n    return jnp.concatenate([self.h_1(z, *h_args), h_2_as_rd1])\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.h_and_Lfh","title":"<code>h_and_Lfh(z, *h_args)</code>","text":"<p>Lie derivative of the barrier function(s) wrt the autonomous dynamics <code>f(z)</code></p> <p>The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>h</code> <code>Array</code> <p>Barrier function evaluation, shape (num_barr,)</p> <code>Lfh</code> <code>Array</code> <p>Lie derivative of <code>h</code> w.r.t. <code>f</code>, shape (num_barr,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def h_and_Lfh(  # pylint: disable=invalid-name\n    self, z: ArrayLike, *h_args\n) -&gt; Tuple[Array, Array]:\n    \"\"\"Lie derivative of the barrier function(s) wrt the autonomous dynamics `f(z)`\n\n    The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        h (Array): Barrier function evaluation, shape (num_barr,)\n        Lfh (Array): Lie derivative of `h` w.r.t. `f`, shape (num_barr,)\n    \"\"\"\n    # Note: the below code is just a more efficient way of stating `Lfh = jax.jacobian(self.h)(z) @ self.f(z)`\n    # with the bonus benefit of also evaluating the barrier function\n\n    def _h(state):\n        return self.h(state, *h_args)\n\n    return jax.jvp(_h, (z,), (self.f(z),))\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.Lgh","title":"<code>Lgh(z, *h_args)</code>","text":"<p>Lie derivative of the barrier function(s) wrt the control dynamics <code>g(z)u</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Lgh, shape (num_barr, m)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def Lgh(self, z: ArrayLike, *h_args) -&gt; Array:  # pylint: disable=invalid-name\n    \"\"\"Lie derivative of the barrier function(s) wrt the control dynamics `g(z)u`\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Lgh, shape (num_barr, m)\n    \"\"\"\n    # Note: the below code is just a more efficient way of stating `Lgh = jax.jacobian(self.h)(z) @ self.g(z)`\n\n    def _h(state):\n        return self.h(state, *h_args)\n\n    def _jvp(g_column):\n        return jax.jvp(_h, (z,), (g_column,))[1]\n\n    return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.P_qp","title":"<code>P_qp(z, u_des, *h_args)</code>","text":"<p>Quadratic term in the QP objective (<code>minimize 0.5 * x^T P x + q^T x</code>)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>P matrix, shape (m, m)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def P_qp(  # pylint: disable=invalid-name\n    self, z: Array, u_des: Array, *h_args\n) -&gt; Array:\n    \"\"\"Quadratic term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: P matrix, shape (m, m)\n    \"\"\"\n    # This is user-modifiable in the config, but defaults to 2 * I for the standard min-norm CBF objective\n    return self.P_config(z, u_des, *h_args)\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.q_qp","title":"<code>q_qp(z, u_des, *h_args)</code>","text":"<p>Linear term in the QP objective (<code>minimize 0.5 * x^T P x + q^T x</code>)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>q vector, shape (m,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def q_qp(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Linear term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: q vector, shape (m,)\n    \"\"\"\n    # This is user-modifiable in the config, but defaults to -2 * u_des for the standard min-norm CBF objective\n    return self.q_config(z, u_des, *h_args)\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.G_qp","title":"<code>G_qp(z, u_des, *h_args)</code>","text":"<p>Inequality constraint matrix for the QP (<code>Gx &lt;= h</code>)</p> Note <p>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>G matrix, shape (num_constraints, m)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def G_qp(  # pylint: disable=invalid-name\n    self, z: Array, u_des: Array, *h_args\n) -&gt; Array:\n    \"\"\"Inequality constraint matrix for the QP (`Gx &lt;= h`)\n\n    Note:\n        The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: G matrix, shape (num_constraints, m)\n    \"\"\"\n    G = -self.Lgh(z, *h_args)\n    if self.control_constrained:\n        return jnp.block([[G], [jnp.eye(self.m)], [-jnp.eye(self.m)]])\n    else:\n        return G\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.h_qp","title":"<code>h_qp(z, u_des, *h_args)</code>","text":"<p>Upper bound on constraints for the QP (<code>Gx &lt;= h</code>)</p> Note <p>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>h vector, shape (num_constraints,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def h_qp(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Upper bound on constraints for the QP (`Gx &lt;= h`)\n\n    Note:\n        The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: h vector, shape (num_constraints,)\n    \"\"\"\n    hz, lfh = self.h_and_Lfh(z, *h_args)\n    h = self.alpha(hz) + lfh\n    if self.control_constrained:\n        return jnp.concatenate(\n            [h, jnp.asarray(self.u_max), -jnp.asarray(self.u_min)]\n        )\n    else:\n        return h\n</code></pre>"},{"location":"api/cbf/#cbfpy.cbfs.cbf.CBF.qp_data","title":"<code>qp_data(z, u_des, *h_args)</code>","text":"<p>Constructs the QP matrices based on the current state and desired control</p> <p>i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:</p> <pre><code>minimize 0.5 * x^T P x + q^T x\nsubject to  A x == b\n            G x &lt;= h\n</code></pre> Note <ul> <li>CBFs do not rely on equality constraints, so <code>A</code> and <code>b</code> are empty.</li> <li>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>P</code> <code>Array</code> <p>Quadratic term in the QP objective, shape (m, m)</p> <code>q</code> <code>Array</code> <p>Linear term in the QP objective, shape (m,)</p> <code>A</code> <code>Array</code> <p>Equality constraint matrix, shape (0, m)</p> <code>b</code> <code>Array</code> <p>Equality constraint vector, shape (0,)</p> <code>G</code> <code>Array</code> <p>Inequality constraint matrix, shape (num_constraints, m)</p> <code>h</code> <code>Array</code> <p>Upper bound on constraints, shape (num_constraints,)</p> Source code in <code>cbfpy/cbfs/cbf.py</code> <pre><code>def qp_data(\n    self, z: Array, u_des: Array, *h_args\n) -&gt; Tuple[Array, Array, Array, Array, Array, Array]:\n    \"\"\"Constructs the QP matrices based on the current state and desired control\n\n    i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:\n\n    ```\n    minimize 0.5 * x^T P x + q^T x\n    subject to  A x == b\n                G x &lt;= h\n    ```\n\n    Note:\n        - CBFs do not rely on equality constraints, so `A` and `b` are empty.\n        - The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        P (Array): Quadratic term in the QP objective, shape (m, m)\n        q (Array): Linear term in the QP objective, shape (m,)\n        A (Array): Equality constraint matrix, shape (0, m)\n        b (Array): Equality constraint vector, shape (0,)\n        G (Array): Inequality constraint matrix, shape (num_constraints, m)\n        h (Array): Upper bound on constraints, shape (num_constraints,)\n    \"\"\"\n    return (\n        self.P_qp(z, u_des, *h_args),\n        self.q_qp(z, u_des, *h_args),\n        jnp.zeros((0, self.m)),  # Equality matrix (not used for CBF)\n        jnp.zeros(0),  # Equality vector (not used for CBF)\n        self.G_qp(z, u_des, *h_args),\n        self.h_qp(z, u_des, *h_args),\n    )\n</code></pre>"},{"location":"api/cbf_config/","title":"CBF Config","text":""},{"location":"api/cbf_config/#cbfpy.config.cbf_config--cbf-configuration-class","title":"CBF Configuration class","text":""},{"location":"api/cbf_config/#cbfpy.config.cbf_config--defining-the-problem","title":"Defining the problem:","text":"<p>CBFs have two primary implementation requirements: the dynamics functions, and the barrier function(s). These can be specified through the <code>f</code>, <code>g</code>, and <code>h</code> methods, respectively. Note that the main requirements for these functions are that (1) the dynamics are control-affine, and (2) the barrier function(s) are \"zeroing\" barriers, as opposed to \"reciprocal\" barriers. A zeroing barrier is one which is positive in the interior of the safe set, and zero on the boundary.</p> <p>Depending on the relative degree of your barrier function(s), you should implement the <code>h_1</code> method (for a relative-degree-1 barrier), and/or the <code>h_2</code> method (for a relative-degree-2 barrier).</p>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config--tuning-the-cbf","title":"Tuning the CBF:","text":"<p>The CBF config provides a default implementation of the CBF \"gain\" function <code>alpha</code>, and <code>alpha_2</code> for relative-degree-2 barriers. To change the sensitivity of the CBF, these functions can be modified to increase or decrease the effect of the barrier(s). For instance, <code>alpha(h) = h</code> is the default implementation, but to increase the sensitivity of the CBF, one could use <code>alpha(h) = 2 * h</code>. The only requirements for these functions are that they are monotonically increasing and pass through the origin (class Kappa functions).</p> <p>The CBFConfig also provides a default implementation of the CBF QP objective function, which is to minimize the norm of the difference between the safe control input and the desired control input. This can also be modified through the <code>P</code> and <code>q</code> methods, which define the quadratic and linear terms in the QP objective, respectively. This does require that P is positive semi-definite.</p>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config--relaxation","title":"Relaxation:","text":"<p>Depending on the construction of the barrier functions and if control limits are provided, the CBF QP may not always be feasible. If allowing for relaxation in the CBFConfig, a slack variable will be introduced to ensure that the problem is always feasible, with a high penalty on any infeasibility. This is generally useful for controller robustness, but means that safety is not guaranteed.</p> <p>If strict enforcement of the CBF is desired, your higest-level controller should handle the case where the QP is infeasible.</p>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig","title":"<code>CBFConfig</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Control Barrier Function (CBF) configuration class.</p> <p>This is an abstract class which requires implementation of the following methods:</p> <ul> <li><code>f(z)</code>: The uncontrolled dynamics function</li> <li><code>g(z)</code>: The control affine dynamics function</li> <li><code>h_1(z)</code> and/or <code>h_2(z)</code>: The barrier function(s), of relative degree 1 and/or 2</li> </ul> <p>For finer-grained control over the CBF, the following methods may be updated from their defaults:</p> <ul> <li><code>alpha(h)</code>: \"Gain\" of the CBF</li> <li><code>alpha_2(h_2)</code>: \"Gain\" of the relative-degree-2 CBFs, if applicable</li> <li><code>P(z, u_des)</code>: Quadratic term in the CBF QP objective</li> <li><code>q(z, u_des)</code>: Linear term in the CBF QP objective</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>State dimension</p> required <code>m</code> <code>int</code> <p>Control dimension</p> required <code>u_min</code> <code>ArrayLike</code> <p>Minimum control input, shape (m,). Defaults to None (Unconstrained).</p> <code>None</code> <code>u_max</code> <code>ArrayLike</code> <p>Maximum control input, shape (m,). Defaults to None (Unconstrained).</p> <code>None</code> <code>relax_qp</code> <code>bool</code> <p>Whether to allow for relaxation in the CBF QP. Defaults to True. Note: this is required for differentiability through the QP.</p> <code>True</code> <code>cbf_relaxation_penalty</code> <code>float</code> <p>Penalty on the CBF slack variables in the relaxed QP. Defaults to 1e3. Note: only applies if relax_qp is True.</p> <code>1000.0</code> <code>control_relaxation_penalty</code> <code>float</code> <p>Penalty on the control constraint slack variables in the relaxed QP. Defaults to 1e5. Note: only applies if relax_qp is True.</p> <code>100000.0</code> <code>solver_tol</code> <code>float</code> <p>Tolerance for the QP solver. Defaults to 1e-3.</p> <code>0.001</code> <code>init_args</code> <code>tuple</code> <p>If your barrier function relies on additional arguments other than just the state, include an initial seed for these arguments here. This is to help test the output of the barrier function. Defaults to ().</p> <code>()</code> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>class CBFConfig(ABC):\n    \"\"\"Control Barrier Function (CBF) configuration class.\n\n    This is an abstract class which requires implementation of the following methods:\n\n    - `f(z)`: The uncontrolled dynamics function\n    - `g(z)`: The control affine dynamics function\n    - `h_1(z)` and/or `h_2(z)`: The barrier function(s), of relative degree 1 and/or 2\n\n    For finer-grained control over the CBF, the following methods may be updated from their defaults:\n\n    - `alpha(h)`: \"Gain\" of the CBF\n    - `alpha_2(h_2)`: \"Gain\" of the relative-degree-2 CBFs, if applicable\n    - `P(z, u_des)`: Quadratic term in the CBF QP objective\n    - `q(z, u_des)`: Linear term in the CBF QP objective\n\n    Args:\n        n (int): State dimension\n        m (int): Control dimension\n        u_min (ArrayLike, optional): Minimum control input, shape (m,). Defaults to None (Unconstrained).\n        u_max (ArrayLike, optional): Maximum control input, shape (m,). Defaults to None (Unconstrained).\n        relax_qp (bool, optional): Whether to allow for relaxation in the CBF QP. Defaults to True.\n            Note: this is required for differentiability through the QP.\n        cbf_relaxation_penalty (float, optional): Penalty on the CBF slack variables in the relaxed QP.\n            Defaults to 1e3. Note: only applies if relax_qp is True.\n        control_relaxation_penalty (float, optional): Penalty on the control constraint slack variables in the\n            relaxed QP. Defaults to 1e5. Note: only applies if relax_qp is True.\n        solver_tol (float, optional): Tolerance for the QP solver. Defaults to 1e-3.\n        init_args (tuple, optional): If your barrier function relies on additional arguments other than just the state,\n            include an initial seed for these arguments here. This is to help test the output of the barrier function.\n            Defaults to ().\n    \"\"\"\n\n    def __init__(\n        self,\n        n: int,\n        m: int,\n        u_min: Optional[ArrayLike] = None,\n        u_max: Optional[ArrayLike] = None,\n        relax_qp: bool = True,\n        cbf_relaxation_penalty: float = 1e3,\n        control_relaxation_penalty: float = 1e5,\n        solver_tol: float = 1e-3,\n        init_args: tuple = (),\n    ):\n        if not (isinstance(n, int) and n &gt; 0):\n            raise ValueError(f\"n must be a positive integer. Got: {n}\")\n        self.n = n\n\n        if not (isinstance(m, int) and m &gt; 0):\n            raise ValueError(f\"m must be a positive integer. Got: {m}\")\n        self.m = m\n\n        if not isinstance(relax_qp, bool):\n            raise ValueError(f\"relax_qp must be a boolean. Got: {relax_qp}\")\n        self.relax_qp = relax_qp\n\n        if not (\n            isinstance(cbf_relaxation_penalty, (int, float))\n            and cbf_relaxation_penalty &gt;= 0\n        ):\n            raise ValueError(\n                f\"CBF relaxation penalty must be a non-negative value. Got: {cbf_relaxation_penalty}\"\n            )\n        self.cbf_relaxation_penalty = float(cbf_relaxation_penalty)\n\n        if not (isinstance(solver_tol, (int, float)) and solver_tol &gt; 0):\n            raise ValueError(f\"solver_tol must be a positive value. Got: {solver_tol}\")\n        self.solver_tol = float(solver_tol)\n\n        if self.solver_tol &gt; 1e-2:\n            print(\n                f\"WARNING: solver tolerance is quite high ({self.solver_tol}). \"\n                + \" Solution will likely be poor.\"\n            )\n\n        if not isinstance(init_args, tuple):\n            raise ValueError(f\"init_args must be a tuple. Got: {init_args}\")\n        self.init_args = init_args\n\n        if not (\n            isinstance(control_relaxation_penalty, (int, float))\n            and control_relaxation_penalty &gt;= 0\n        ):\n            raise ValueError(\n                f\"control_relaxation_penalty must be a non-negative value. Got: {control_relaxation_penalty}\"\n            )\n        self.control_relaxation_penalty = float(control_relaxation_penalty)\n\n        # Control limits require a bit of extra handling. They can be both None if unconstrained,\n        # but we should not have one limit as None and the other as some value\n        u_min = np.asarray(u_min, dtype=float).flatten() if u_min is not None else None\n        u_max = np.asarray(u_max, dtype=float).flatten() if u_max is not None else None\n        if u_min is not None or u_max is not None:\n            self.control_constrained = True\n            if u_min is None and u_max is not None:\n                u_min = -np.inf * np.ones(self.m)\n            elif u_min is not None and u_max is None:\n                u_max = np.inf * np.ones(self.m)\n        else:\n            self.control_constrained = False\n        if u_min is not None:\n            assert u_min.shape == (self.m,)\n            u_min = tuple(u_min)\n        if u_max is not None:\n            assert u_max.shape == (self.m,)\n            u_max = tuple(u_max)\n        self.u_min = u_min\n        self.u_max = u_max\n\n        if (\n            self.control_constrained\n            and self.control_relaxation_penalty &lt; self.cbf_relaxation_penalty\n        ):\n            print(\"WARNING: Control constraints have a lower penalty than the CBFs.\")\n\n        # Test if the methods are provided and verify their output dimension\n        z_test = jnp.ones(self.n)\n        u_test = jnp.ones(self.m)\n        f_test = self.f(z_test)\n        g_test = self.g(z_test)\n        if f_test.shape != (self.n,):\n            raise ValueError(\n                f\"Invalid shape for f(z). Got {f_test.shape}, expected ({self.n},)\"\n            )\n        if g_test.shape != (self.n, self.m):\n            raise ValueError(\n                f\"Invalid shape for g(z). Got {g_test.shape}, expected ({self.n}, {self.m})\"\n            )\n        try:\n            h1_test = self.h_1(z_test, *self.init_args)\n            h2_test = self.h_2(z_test, *self.init_args)\n        except TypeError as e:\n            raise ValueError(\n                \"Cannot test the barrier function; likely missing additional arguments.\\n\"\n                + \"Please provide an initial seed for these args in the config's init_args input\"\n            ) from e\n        if h1_test.ndim != 1 or h2_test.ndim != 1:\n            raise ValueError(\"Barrier function(s) must be 1D arrays\")\n        self.num_rd1_cbf = h1_test.shape[0]\n        self.num_rd2_cbf = h2_test.shape[0]\n        self.num_cbf = self.num_rd1_cbf + self.num_rd2_cbf\n        if self.num_cbf == 0:\n            raise ValueError(\n                \"No barrier functions provided.\"\n                + \"\\nYou can implement this via the h_1 and/or h_2 methods in your config class\"\n            )\n        h_test = jnp.concatenate([h1_test, h2_test])\n        alpha_test = self.alpha(h_test)\n        alpha_2_test = self.alpha_2(h2_test)\n        if alpha_test.shape != (self.num_cbf,):\n            raise ValueError(\n                f\"Invalid shape for alpha(h(z)): {alpha_test.shape}. Expected ({self.num_cbf},)\"\n                + \"\\nCheck that the output of the alpha() function matches the number of CBFs\"\n            )\n        if alpha_2_test.shape != (self.num_rd2_cbf,):\n            raise ValueError(\n                f\"Invalid shape for alpha_2(h_2(z)): {alpha_2_test.shape}. Expected ({self.num_rd2_cbf},)\"\n                + \"\\nCheck that the output of the alpha_2() function matches the number of RD2 CBFs\"\n            )\n        self._check_class_kappa(self.alpha, self.num_cbf)\n        self._check_class_kappa(self.alpha_2, self.num_rd2_cbf)\n        try:\n            P_test = self.P(z_test, u_test, *self.init_args)\n        except TypeError as e:\n            raise ValueError(\n                \"Cannot test the P matrix; likely missing additional arguments.\\n\"\n                + \"Please provide an initial seed for these args in the config's init_args input\"\n            ) from e\n        if P_test.shape != (self.m, self.m):\n            raise ValueError(\n                f\"Invalid shape for P(z). Got {P_test.shape}, expected ({self.m}, {self.m})\"\n            )\n        if not self._is_symmetric_psd(P_test):\n            raise ValueError(\"P matrix must be symmetric positive semi-definite\")\n\n        # Handle QP relaxation penalties, if relaxation is enabled\n        num_qp_constraints = (\n            self.num_cbf if not self.control_constrained else self.num_cbf + 2 * self.m\n        )\n        if self.control_constrained:\n            self.constraint_relaxation_penalties = tuple(\n                np.concatenate(\n                    [\n                        self.cbf_relaxation_penalty * np.ones(self.num_cbf),\n                        self.control_relaxation_penalty * np.ones(2 * self.m),\n                    ]\n                )\n            )\n        else:\n            self.constraint_relaxation_penalties = tuple(\n                self.cbf_relaxation_penalty * np.ones(self.num_cbf)\n            )\n        assert len(self.constraint_relaxation_penalties) == num_qp_constraints\n\n    ## Control Affine Dynamics ##\n\n    @abstractmethod\n    def f(self, z: ArrayLike) -&gt; Array:\n        \"\"\"The uncontrolled dynamics function. Possibly nonlinear, and locally Lipschitz\n\n        i.e. the function f, such that z_dot = f(z) + g(z) u\n\n        Args:\n            z (ArrayLike): The state, shape (n,)\n\n        Returns:\n            Array: Uncontrolled state derivative component, shape (n,)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def g(self, z: ArrayLike) -&gt; Array:\n        \"\"\"The control affine dynamics function. Locally Lipschitz.\n\n        i.e. the function g, such that z_dot = f(z) + g(z) u\n\n        Args:\n            z (ArrayLike): The state, shape (n,)\n\n        Returns:\n            Array: Control matrix, shape (n, m)\n        \"\"\"\n        pass\n\n    ## Barriers ##\n\n    def h_1(self, z: ArrayLike, *h_args) -&gt; Array:\n        \"\"\"Relative-degree-1 barrier function(s).\n\n        A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n        the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n        Relative degree can generally be thought of as the number of integrations required between the\n        input and output of the system. For instance, a (relative-degree-1) CBF based on velocities,\n        with acceleration inputs, will be directly modified on the next timestep.\n\n        If your barrier function is relative-degree-2, or if you would like to enforce additional barriers\n        which are relative-degree-2, use the `h_2` method.\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n                barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n        Returns:\n            Array: Barrier function(s), shape (num_rd1_barr,)\n        \"\"\"\n        return jnp.array([])\n\n    def h_2(self, z: ArrayLike, *h_args) -&gt; Array:\n        \"\"\"Relative-degree-2 (high-order) barrier function(s).\n\n        A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n        the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n        Relative degree can generally be thought of as the number of integrations required between the\n        input and output of the system. For instance, a (relative-degree-2) CBF based on position,\n        with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity,\n        which then changes the position.\n\n        If your barrier function is relative-degree-1, or if you would like to enforce additional barriers\n        which are relative-degree-1, use the `h_1` method.\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n                barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n        Returns:\n            Array: Barrier function(s), shape (num_rd2_barr,)\n        \"\"\"\n        return jnp.array([])\n\n    ## Additional tuning functions ##\n\n    def alpha(self, h: ArrayLike) -&gt; Array:\n        \"\"\"A class Kappa function, dictating the \"gain\" of the barrier function(s)\n\n        For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n        A simple example is alpha(h) = h\n\n        The default implementation can be overridden for more fine-grained control over the CBF\n\n        Args:\n            h (ArrayLike): Evaluation of the barrier function(s) at the current state, shape (num_cbf,)\n\n        Returns:\n            Array: alpha(h(z)), shape (num_cbf,)\n        \"\"\"\n        return h\n\n    def alpha_2(self, h_2: ArrayLike) -&gt; Array:\n        \"\"\"A second class Kappa function which dictactes the \"gain\" associated with the relative-degree-2\n        barrier functions\n\n        For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n        A simple example is alpha_2(h_2) = h_2\n\n        The default implementation can be overridden for more fine-grained control over the CBF\n\n        Args:\n            h_2 (ArrayLike): Evaluation of the RD2 barrier function(s) at the current state, shape (num_rd2_cbf,)\n\n        Returns:\n            Array: alpha_2(h_2(z)), shape (num_rd2_cbf,).\n        \"\"\"\n        return h_2\n\n    # Objective function tuning\n\n    def P(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n        \"\"\"Quadratic term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n        This defaults to 2 * I, which is the value of P when minimizing the standard CBF objective,\n        ||u - u_des||_{2}^{2}\n\n        To change the objective, override this method. **Note that P must be PSD**\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: P matrix, shape (m, m)\n        \"\"\"\n        return 2 * jnp.eye(self.m)\n\n    def q(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n        \"\"\"Linear term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n        This defaults to -2 * u_des, which is the value of q when minimizing the standard CBF objective,\n        ||u - u_des||_{2}^{2}\n\n        To change the objective, override this method.\n\n        Args:\n            z (Array): State, shape (n,)\n            u_des (Array): Desired control input, shape (m,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: q vector, shape (m,)\n        \"\"\"\n        return -2 * u_des\n\n    ## Helper functions ##\n\n    def _check_class_kappa(\n        self, func: Callable[[ArrayLike], ArrayLike], dim: int\n    ) -&gt; None:\n        \"\"\"Checks that the provided function is in class Kappa\n\n        Args:\n            func (Callable): Function to check\n            dim (int): Expected dimension of the output\n        \"\"\"\n        assert isinstance(func, Callable)\n        try:\n            # Check that func(0) == 0\n            assert jnp.allclose(func(jnp.zeros(dim)), 0.0)\n            # Check that func is monotonically increasing\n            n_test = 100\n            test_points = jnp.repeat(\n                jnp.linspace(-1e6, 1e6, n_test).reshape(n_test, 1), dim, axis=1\n            )\n            a = jax.vmap(func, in_axes=0)(test_points)\n            assert jnp.all(a[:-1, :] &lt; a[1:, :])\n        except AssertionError as e:\n            raise ValueError(\n                f\"{func.__name__} does not appear to be a class Kappa function\"\n            ) from e\n\n    def _is_symmetric_psd(self, mat: Array) -&gt; bool:\n        \"\"\"Check that a matrix is symmetric positive semi-definite\n\n        Args:\n            mat (Array): Matrix to check\n\n        Returns:\n            bool: True if the matrix is symmetric PSD, False otherwise\n        \"\"\"\n        mat = np.asarray(mat)\n        # Must be square\n        if mat.shape[0] != mat.shape[1]:\n            return False\n        # Must be symmetric or hermitian\n        if not np.allclose(mat, mat.conj().T, atol=1e-14):\n            return False\n        # Check PSD with cholesky. Cholesky can only tell if a matrix is PD, not PSD,\n        # but adding a small regularization term will allow this test to work\n        try:\n            np.linalg.cholesky(mat + np.eye(mat.shape[0]) * 1e-14)\n        except np.linalg.LinAlgError:\n            return False\n        return True\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.f","title":"<code>f(z)</code>  <code>abstractmethod</code>","text":"<p>The uncontrolled dynamics function. Possibly nonlinear, and locally Lipschitz</p> <p>i.e. the function f, such that z_dot = f(z) + g(z) u</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Uncontrolled state derivative component, shape (n,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>@abstractmethod\ndef f(self, z: ArrayLike) -&gt; Array:\n    \"\"\"The uncontrolled dynamics function. Possibly nonlinear, and locally Lipschitz\n\n    i.e. the function f, such that z_dot = f(z) + g(z) u\n\n    Args:\n        z (ArrayLike): The state, shape (n,)\n\n    Returns:\n        Array: Uncontrolled state derivative component, shape (n,)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.g","title":"<code>g(z)</code>  <code>abstractmethod</code>","text":"<p>The control affine dynamics function. Locally Lipschitz.</p> <p>i.e. the function g, such that z_dot = f(z) + g(z) u</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Control matrix, shape (n, m)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>@abstractmethod\ndef g(self, z: ArrayLike) -&gt; Array:\n    \"\"\"The control affine dynamics function. Locally Lipschitz.\n\n    i.e. the function g, such that z_dot = f(z) + g(z) u\n\n    Args:\n        z (ArrayLike): The state, shape (n,)\n\n    Returns:\n        Array: Control matrix, shape (n, m)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.h_1","title":"<code>h_1(z, *h_args)</code>","text":"<p>Relative-degree-1 barrier function(s).</p> <p>A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-1) CBF based on velocities, with acceleration inputs, will be directly modified on the next timestep.</p> <p>If your barrier function is relative-degree-2, or if you would like to enforce additional barriers which are relative-degree-2, use the <code>h_2</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function. Note: If using additional args with your barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function(s), shape (num_rd1_barr,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def h_1(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Relative-degree-1 barrier function(s).\n\n    A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n    the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-1) CBF based on velocities,\n    with acceleration inputs, will be directly modified on the next timestep.\n\n    If your barrier function is relative-degree-2, or if you would like to enforce additional barriers\n    which are relative-degree-2, use the `h_2` method.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n            barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n    Returns:\n        Array: Barrier function(s), shape (num_rd1_barr,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.h_2","title":"<code>h_2(z, *h_args)</code>","text":"<p>Relative-degree-2 (high-order) barrier function(s).</p> <p>A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-2) CBF based on position, with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity, which then changes the position.</p> <p>If your barrier function is relative-degree-1, or if you would like to enforce additional barriers which are relative-degree-1, use the <code>h_1</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function. Note: If using additional args with your barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function(s), shape (num_rd2_barr,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def h_2(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Relative-degree-2 (high-order) barrier function(s).\n\n    A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n    the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-2) CBF based on position,\n    with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity,\n    which then changes the position.\n\n    If your barrier function is relative-degree-1, or if you would like to enforce additional barriers\n    which are relative-degree-1, use the `h_1` method.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n            barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n    Returns:\n        Array: Barrier function(s), shape (num_rd2_barr,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.alpha","title":"<code>alpha(h)</code>","text":"<p>A class Kappa function, dictating the \"gain\" of the barrier function(s)</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin. A simple example is alpha(h) = h</p> <p>The default implementation can be overridden for more fine-grained control over the CBF</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>ArrayLike</code> <p>Evaluation of the barrier function(s) at the current state, shape (num_cbf,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>alpha(h(z)), shape (num_cbf,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def alpha(self, h: ArrayLike) -&gt; Array:\n    \"\"\"A class Kappa function, dictating the \"gain\" of the barrier function(s)\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n    A simple example is alpha(h) = h\n\n    The default implementation can be overridden for more fine-grained control over the CBF\n\n    Args:\n        h (ArrayLike): Evaluation of the barrier function(s) at the current state, shape (num_cbf,)\n\n    Returns:\n        Array: alpha(h(z)), shape (num_cbf,)\n    \"\"\"\n    return h\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.alpha_2","title":"<code>alpha_2(h_2)</code>","text":"<p>A second class Kappa function which dictactes the \"gain\" associated with the relative-degree-2 barrier functions</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin. A simple example is alpha_2(h_2) = h_2</p> <p>The default implementation can be overridden for more fine-grained control over the CBF</p> <p>Parameters:</p> Name Type Description Default <code>h_2</code> <code>ArrayLike</code> <p>Evaluation of the RD2 barrier function(s) at the current state, shape (num_rd2_cbf,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>alpha_2(h_2(z)), shape (num_rd2_cbf,).</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def alpha_2(self, h_2: ArrayLike) -&gt; Array:\n    \"\"\"A second class Kappa function which dictactes the \"gain\" associated with the relative-degree-2\n    barrier functions\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n    A simple example is alpha_2(h_2) = h_2\n\n    The default implementation can be overridden for more fine-grained control over the CBF\n\n    Args:\n        h_2 (ArrayLike): Evaluation of the RD2 barrier function(s) at the current state, shape (num_rd2_cbf,)\n\n    Returns:\n        Array: alpha_2(h_2(z)), shape (num_rd2_cbf,).\n    \"\"\"\n    return h_2\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.P","title":"<code>P(z, u_des, *h_args)</code>","text":"<p>Quadratic term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)</p> <p>This defaults to 2 * I, which is the value of P when minimizing the standard CBF objective, ||u - u_des||_{2}^{2}</p> <p>To change the objective, override this method. Note that P must be PSD</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>P matrix, shape (m, m)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def P(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Quadratic term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n    This defaults to 2 * I, which is the value of P when minimizing the standard CBF objective,\n    ||u - u_des||_{2}^{2}\n\n    To change the objective, override this method. **Note that P must be PSD**\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: P matrix, shape (m, m)\n    \"\"\"\n    return 2 * jnp.eye(self.m)\n</code></pre>"},{"location":"api/cbf_config/#cbfpy.config.cbf_config.CBFConfig.q","title":"<code>q(z, u_des, *h_args)</code>","text":"<p>Linear term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)</p> <p>This defaults to -2 * u_des, which is the value of q when minimizing the standard CBF objective, ||u - u_des||_{2}^{2}</p> <p>To change the objective, override this method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>q vector, shape (m,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def q(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Linear term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n    This defaults to -2 * u_des, which is the value of q when minimizing the standard CBF objective,\n    ||u - u_des||_{2}^{2}\n\n    To change the objective, override this method.\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: q vector, shape (m,)\n    \"\"\"\n    return -2 * u_des\n</code></pre>"},{"location":"api/clf_cbf/","title":"CLF-CBF","text":""},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf--control-lyapunov-function-control-barrier-functions-clf-cbfs","title":"Control Lyapunov Function / Control Barrier Functions (CLF-CBFs)","text":"<p>Whereas a CBF acts as a safety filter on top of a nominal controller, a CLF-CBF acts as a safe controller itself, based on a control objective defined by the CLF and a safety constraint defined by the CBF. Note that the CLF objective should be quadratic and positive-definite to fit in this QP framework.</p> <p>The CLF-CBF optimizes the following: <pre><code>minimize   ||u||_{2}^{2}                     # CLF Objective (Example)\nsubject to LfV(z) + LgV(z)u &lt;= -gamma(V(z))  # CLF Constraint\n           Lfh(z) + Lgh(z)u &gt;= -alpha(h(z))  # CBF Constraint\n</code></pre></p> <p>As with the CBF, if this is a relative-degree-2 system, we update the constraints: <pre><code>minimize   ||u||_{2}^{2}                             # CLF Objective (Example)\nsubject to LfV_2(z) + LgV_2(z)u &lt;= -gamma_2(V_2(z))  # RD2 CLF Constraint\n           Lfh_2(z) + Lgh_2(z)u &gt;= -alpha_2(h_2(z))  # RD2 CBF Constraint\n</code></pre></p> <p>If there are constraints on the control input, we also enforce another constraint: <pre><code>u_min &lt;= u &lt;= u_max  # Control constraint\n</code></pre></p> <p>However, in general the CLF constraint and the CBF constraint cannot be strictly enforced together. We then need to introduce a slack variable to relax the CLF constraint, ensuring that the CBF safety condition takes priority over the CLF objective.</p> <p>The optimization problem then becomes: <pre><code>minimize   ||u||_{2}^{2} + p * delta^2               # CLF Objective (Example)\nsubject to LfV(z) + LgV(z)u &lt;= -gamma(V(z)) + delta  # CLF Constraint\n           Lfh(z) + Lgh(z)u &gt;= -alpha(h(z))          # CBF Constraint\n</code></pre> where <code>p</code> is a large constant and <code>delta</code> is the slack variable.</p>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF","title":"<code>CLFCBF</code>","text":"<p>Control Lyapunov Function / Control Barrier Function (CLF-CBF) class.</p> <p>The main constructor for this class is via the <code>from_config</code> method, which constructs a CLF-CBF instance based on the provided CLFCBFConfig configuration object.</p> <p>You can then use the CLF-CBF's <code>controller</code> method to compute the optimal control input</p> <p>Examples:</p> <pre><code># Construct a CLFCBFConfig for your problem\nconfig = DroneConfig()\n# Construct a CBF instance based on the config\nclf_cbf = CLFCBF.from_config(config)\n# Compute the safe control input\nsafe_control = clf_cbf.controller(current_state, desired_state)\n</code></pre> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>@jax.tree_util.register_static\nclass CLFCBF:\n    \"\"\"Control Lyapunov Function / Control Barrier Function (CLF-CBF) class.\n\n    The main constructor for this class is via the `from_config` method, which constructs a CLF-CBF instance\n    based on the provided CLFCBFConfig configuration object.\n\n    You can then use the CLF-CBF's `controller` method to compute the optimal control input\n\n    Examples:\n        ```\n        # Construct a CLFCBFConfig for your problem\n        config = DroneConfig()\n        # Construct a CBF instance based on the config\n        clf_cbf = CLFCBF.from_config(config)\n        # Compute the safe control input\n        safe_control = clf_cbf.controller(current_state, desired_state)\n        ```\n    \"\"\"\n\n    # NOTE: The __init__ method is not used to construct a CLFCBF instance. Instead, use the `from_config` method.\n    # This is because Jax prefers for the __init__ method to not contain any input validation, so we do this\n    # in the CLFCBFConfig class instead.\n    def __init__(\n        self,\n        n: int,\n        m: int,\n        num_cbf: int,\n        num_clf: int,\n        u_min: Optional[tuple],\n        u_max: Optional[tuple],\n        control_constrained: bool,\n        relax_qp: bool,\n        clf_relaxation_penalty: float,\n        constraint_relaxation_penalties: tuple,\n        h_1: Callable[[ArrayLike], Array],\n        h_2: Callable[[ArrayLike], Array],\n        f: Callable[[ArrayLike], Array],\n        g: Callable[[ArrayLike], Array],\n        alpha: Callable[[ArrayLike], Array],\n        alpha_2: Callable[[ArrayLike], Array],\n        V_1: Callable[[ArrayLike], Array],\n        V_2: Callable[[ArrayLike], Array],\n        gamma: Callable[[ArrayLike], Array],\n        gamma_2: Callable[[ArrayLike], Array],\n        H: Callable[[ArrayLike], Array],\n        F: Callable[[ArrayLike], Array],\n        solver_tol: float,\n    ):\n        self.n = n\n        self.m = m\n        self.num_cbf = num_cbf\n        self.num_clf = num_clf\n        self.u_min = u_min\n        self.u_max = u_max\n        self.control_constrained = control_constrained\n        self.relax_qp = relax_qp\n        self.clf_relaxation_penalty = clf_relaxation_penalty\n        self.constraint_relaxation_penalties = constraint_relaxation_penalties\n        self.h_1 = h_1\n        self.h_2 = h_2\n        self.f = f\n        self.g = g\n        self.alpha = alpha\n        self.alpha_2 = alpha_2\n        self.V_1 = V_1\n        self.V_2 = V_2\n        self.gamma = gamma\n        self.gamma_2 = gamma_2\n        self.H = H\n        self.F = F\n        self.solver_tol = solver_tol\n\n    @classmethod\n    def from_config(cls, config: CLFCBFConfig) -&gt; \"CLFCBF\":\n        \"\"\"Construct a CLF-CBF based on the provided configuration\n\n        Args:\n            config (CLFCBFConfig): Config object for the CLF-CBF. Contains info on the system dynamics, barrier\n                function, Lyapunov function, etc.\n\n        Returns:\n            CLFCBF: Control Lyapunov Function / Control Barrier Function instance\n        \"\"\"\n        instance = cls(\n            config.n,\n            config.m,\n            config.num_cbf,\n            config.num_clf,\n            config.u_min,\n            config.u_max,\n            config.control_constrained,\n            config.relax_qp,\n            config.clf_relaxation_penalty,\n            config.constraint_relaxation_penalties,\n            config.h_1,\n            config.h_2,\n            config.f,\n            config.g,\n            config.alpha,\n            config.alpha_2,\n            config.V_1,\n            config.V_2,\n            config.gamma,\n            config.gamma_2,\n            config.H,\n            config.F,\n            config.solver_tol,\n        )\n        instance._validate_instance(*config.init_args)\n        return instance\n\n    def _validate_instance(self, *h_args) -&gt; None:\n        \"\"\"Checks that the CLF-CBF is valid; warns the user if not\n\n        Args:\n            *h_args: Optional additional arguments for the barrier function.\n        \"\"\"\n        test_z = jnp.ones(self.n)\n        try:\n            test_lgh = self.Lgh(test_z, *h_args)\n            if jnp.allclose(test_lgh, 0):\n                print_warning(\n                    \"Lgh is zero. Consider increasing the relative degree or modifying the barrier function.\"\n                )\n        except TypeError:\n            print_warning(\n                \"Cannot test Lgh; missing additional arguments.\\n\"\n                + \"Please provide an initial seed for these args in the config's init_args input\"\n            )\n        test_lgv = self.LgV(test_z, test_z)\n        if jnp.allclose(test_lgv, 0):\n            print_warning(\n                \"LgV is zero. Consider increasing the relative degree or modifying the Lyapunov function.\"\n            )\n\n    @jax.jit\n    def controller(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n        \"\"\"Compute the CLF-CBF optimal control input, optimizing for the CLF objective while\n        satisfying the CBF safety constraint.\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Safe control input, shape (m,)\n        \"\"\"\n        P, q, A, b, G, h = self.qp_data(z, z_des, *h_args)\n        if self.relax_qp:\n            x_qp = qpax.solve_qp_elastic_primal(\n                P,\n                q,\n                G,\n                h,\n                penalty=jnp.asarray(self.constraint_relaxation_penalties),\n                solver_tol=self.solver_tol,\n            )\n        else:\n            x_qp, s_qp, z_qp, y_qp, converged, iters = qpax.solve_qp(\n                P,\n                q,\n                A,\n                b,\n                G,\n                h,\n                solver_tol=self.solver_tol,\n            )\n        return x_qp[: self.m]\n\n    def h(self, z: ArrayLike, *h_args) -&gt; Array:\n        \"\"\"Barrier function(s)\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Barrier function evaluation, shape (num_barr,)\n        \"\"\"\n\n        # Take any relative-degree-2 barrier functions and convert them to relative-degree-1\n        def _h_2(state):\n            return self.h_2(state, *h_args)\n\n        h_2, dh_2_dt = jax.jvp(_h_2, (z,), (self.f(z),))\n        h_2_as_rd1 = dh_2_dt + self.alpha_2(h_2)\n\n        # Merge the relative-degree-1 and relative-degree-2 barrier functions\n        return jnp.concatenate([self.h_1(z, *h_args), h_2_as_rd1])\n\n    def h_and_Lfh(  # pylint: disable=invalid-name\n        self, z: ArrayLike, *h_args\n    ) -&gt; Tuple[Array, Array]:\n        \"\"\"Lie derivative of the barrier function(s) wrt the autonomous dynamics `f(z)`\n\n        The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            h (Array): Barrier function evaluation, shape (num_barr,)\n            Lfh (Array): Lie derivative of `h` w.r.t. `f`, shape (num_barr,)\n        \"\"\"\n        # Note: the below code is just a more efficient way of stating `Lfh = jax.jacobian(self.h)(z) @ self.f(z)`\n        # with the bonus benefit of also evaluating the barrier function\n\n        def _h(state):\n            return self.h(state, *h_args)\n\n        return jax.jvp(_h, (z,), (self.f(z),))\n\n    def Lgh(self, z: ArrayLike, *h_args) -&gt; Array:  # pylint: disable=invalid-name\n        \"\"\"Lie derivative of the barrier function(s) wrt the control dynamics `g(z)u`\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Lgh, shape (num_barr, m)\n        \"\"\"\n        # Note: the below code is just a more efficient way of stating `Lgh = jax.jacobian(self.h)(z) @ self.g(z)`\n\n        def _h(state):\n            return self.h(state, *h_args)\n\n        def _jvp(g_column):\n            return jax.jvp(_h, (z,), (g_column,))[1]\n\n        return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n\n    ## CLF functions ##\n\n    def V(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n        \"\"\"Control Lyapunov Function(s)\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            z_des (ArrayLike): Desired state, shape (n,)\n\n        Returns:\n            Array: CLF evaluation, shape (num_clf,)\n        \"\"\"\n\n        def _V_2(state):\n            return self.V_2(state, z_des)\n\n        # Take any relative-degree-2 CLFs and convert them to relative-degree-1\n        # NOTE: If adding args to the CLF, create a wrapper func like with the barrier function\n        V_2, dV_2_dt = jax.jvp(_V_2, (z,), (self.f(z),))\n        V2_rd1 = dV_2_dt + self.gamma_2(V_2)\n\n        # Merge the relative-degree-1 and relative-degree-2 CLFs\n        return jnp.concatenate([self.V_1(z, z_des), V2_rd1])\n\n    def V_and_LfV(self, z: ArrayLike, z_des: ArrayLike) -&gt; Tuple[Array, Array]:\n        \"\"\"Lie derivative of the CLF wrt the autonomous dynamics `f(z)`\n\n        The evaluation of the CLF is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            z_des (ArrayLike): Desired state, shape (n,)\n\n        Returns:\n            V (Array): CLF evaluation, shape (1,)\n            LfV (Array): Lie derivative of `V` w.r.t. `f`, shape (1,)\n        \"\"\"\n\n        def _V(state):\n            return self.V(state, z_des)\n\n        return jax.jvp(_V, (z,), (self.f(z),))\n\n    def LgV(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n        \"\"\"Lie derivative of the CLF wrt the control dynamics `g(z)u`\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            z_des (ArrayLike): Desired state, shape (n,)\n\n        Returns:\n            Array: LgV, shape (m,)\n        \"\"\"\n\n        def _V(state):\n            return self.V(state, z_des)\n\n        def _jvp(g_column):\n            return jax.jvp(_V, (z,), (g_column,))[1]\n\n        return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n\n    ## QP Matrices ##\n\n    def P_qp(  # pylint: disable=invalid-name\n        self, z: Array, z_des: Array, *h_args\n    ) -&gt; Array:\n        \"\"\"Quadratic term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: P matrix, shape (m, m)\n        \"\"\"\n        return jnp.block(\n            [\n                [self.H(z), jnp.zeros((self.m, 1))],\n                [jnp.zeros((1, self.m)), jnp.atleast_1d(self.clf_relaxation_penalty)],\n            ]\n        )\n\n    def q_qp(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n        \"\"\"Linear term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: Q vector, shape (m,)\n        \"\"\"\n        return jnp.concatenate([self.F(z), jnp.array([0.0])])\n\n    def G_qp(  # pylint: disable=invalid-name\n        self, z: Array, z_des: Array, *h_args\n    ) -&gt; Array:\n        \"\"\"Inequality constraint matrix for the QP (`Gx &lt;= h`)\n\n        Note:\n            The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: G matrix, shape (num_constraints, m)\n        \"\"\"\n        G = jnp.block(\n            [\n                [self.LgV(z, z_des), -1.0 * jnp.ones((self.num_clf, 1))],\n                [-self.Lgh(z, *h_args), jnp.zeros((self.num_cbf, 1))],\n            ]\n        )\n        if self.control_constrained:\n            return jnp.block(\n                [\n                    [G],\n                    [jnp.eye(self.m), jnp.zeros((self.m, 1))],\n                    [-jnp.eye(self.m), jnp.zeros((self.m, 1))],\n                ]\n            )\n        else:\n            return G\n\n    def h_qp(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n        \"\"\"Upper bound on constraints for the QP (`Gx &lt;= h`)\n\n        Note:\n            The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            Array: h vector, shape (num_constraints,)\n        \"\"\"\n        hz, lfh = self.h_and_Lfh(z, *h_args)\n        vz, lfv = self.V_and_LfV(z, z_des)\n        h = jnp.concatenate(\n            [\n                -lfv - self.gamma(vz),\n                self.alpha(hz) + lfh,\n            ]\n        )\n        if self.control_constrained:\n            return jnp.concatenate(\n                [h, jnp.asarray(self.u_max), -jnp.asarray(self.u_min)]\n            )\n        else:\n            return h\n\n    def qp_data(\n        self, z: Array, z_des: Array, *h_args\n    ) -&gt; Tuple[Array, Array, Array, Array, Array, Array]:\n        \"\"\"Constructs the QP matrices based on the current state and desired control\n\n        i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:\n\n        ```\n        minimize 0.5 * x^T P x + q^T x\n        subject to  A x == b\n                    G x &lt;= h\n        ```\n\n        Note:\n            - CBFs do not rely on equality constraints, so `A` and `b` are empty.\n            - The number of constraints depends on if we have control constraints or not.\n                Without control constraints, `num_constraints == num_barriers`.\n                With control constraints, `num_constraints == num_barriers + 2*m`\n\n        Args:\n            z (Array): State, shape (n,)\n            z_des (Array): Desired state, shape (n,)\n            *h_args: Optional additional arguments for the barrier function.\n\n        Returns:\n            P (Array): Quadratic term in the QP objective, shape (m + 1, m + 1)\n            q (Array): Linear term in the QP objective, shape (m + 1,)\n            A (Array): Equality constraint matrix, shape (0, m + 1)\n            b (Array): Equality constraint vector, shape (0,)\n            G (Array): Inequality constraint matrix, shape (num_constraints, m + 1)\n            h (Array): Upper bound on constraints, shape (num_constraints,)\n        \"\"\"\n        return (\n            self.P_qp(z, z_des, *h_args),\n            self.q_qp(z, z_des, *h_args),\n            jnp.zeros((0, self.m + 1)),  # Equality matrix (not used for CLF-CBF)\n            jnp.zeros(0),  # Equality vector (not used for CLF-CBF)\n            self.G_qp(z, z_des, *h_args),\n            self.h_qp(z, z_des, *h_args),\n        )\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.from_config","title":"<code>from_config(config)</code>  <code>classmethod</code>","text":"<p>Construct a CLF-CBF based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CLFCBFConfig</code> <p>Config object for the CLF-CBF. Contains info on the system dynamics, barrier function, Lyapunov function, etc.</p> required <p>Returns:</p> Name Type Description <code>CLFCBF</code> <code>CLFCBF</code> <p>Control Lyapunov Function / Control Barrier Function instance</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>@classmethod\ndef from_config(cls, config: CLFCBFConfig) -&gt; \"CLFCBF\":\n    \"\"\"Construct a CLF-CBF based on the provided configuration\n\n    Args:\n        config (CLFCBFConfig): Config object for the CLF-CBF. Contains info on the system dynamics, barrier\n            function, Lyapunov function, etc.\n\n    Returns:\n        CLFCBF: Control Lyapunov Function / Control Barrier Function instance\n    \"\"\"\n    instance = cls(\n        config.n,\n        config.m,\n        config.num_cbf,\n        config.num_clf,\n        config.u_min,\n        config.u_max,\n        config.control_constrained,\n        config.relax_qp,\n        config.clf_relaxation_penalty,\n        config.constraint_relaxation_penalties,\n        config.h_1,\n        config.h_2,\n        config.f,\n        config.g,\n        config.alpha,\n        config.alpha_2,\n        config.V_1,\n        config.V_2,\n        config.gamma,\n        config.gamma_2,\n        config.H,\n        config.F,\n        config.solver_tol,\n    )\n    instance._validate_instance(*config.init_args)\n    return instance\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.controller","title":"<code>controller(z, z_des, *h_args)</code>","text":"<p>Compute the CLF-CBF optimal control input, optimizing for the CLF objective while satisfying the CBF safety constraint.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Safe control input, shape (m,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>@jax.jit\ndef controller(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n    \"\"\"Compute the CLF-CBF optimal control input, optimizing for the CLF objective while\n    satisfying the CBF safety constraint.\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Safe control input, shape (m,)\n    \"\"\"\n    P, q, A, b, G, h = self.qp_data(z, z_des, *h_args)\n    if self.relax_qp:\n        x_qp = qpax.solve_qp_elastic_primal(\n            P,\n            q,\n            G,\n            h,\n            penalty=jnp.asarray(self.constraint_relaxation_penalties),\n            solver_tol=self.solver_tol,\n        )\n    else:\n        x_qp, s_qp, z_qp, y_qp, converged, iters = qpax.solve_qp(\n            P,\n            q,\n            A,\n            b,\n            G,\n            h,\n            solver_tol=self.solver_tol,\n        )\n    return x_qp[: self.m]\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.h","title":"<code>h(z, *h_args)</code>","text":"<p>Barrier function(s)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function evaluation, shape (num_barr,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def h(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Barrier function(s)\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Barrier function evaluation, shape (num_barr,)\n    \"\"\"\n\n    # Take any relative-degree-2 barrier functions and convert them to relative-degree-1\n    def _h_2(state):\n        return self.h_2(state, *h_args)\n\n    h_2, dh_2_dt = jax.jvp(_h_2, (z,), (self.f(z),))\n    h_2_as_rd1 = dh_2_dt + self.alpha_2(h_2)\n\n    # Merge the relative-degree-1 and relative-degree-2 barrier functions\n    return jnp.concatenate([self.h_1(z, *h_args), h_2_as_rd1])\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.h_and_Lfh","title":"<code>h_and_Lfh(z, *h_args)</code>","text":"<p>Lie derivative of the barrier function(s) wrt the autonomous dynamics <code>f(z)</code></p> <p>The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>h</code> <code>Array</code> <p>Barrier function evaluation, shape (num_barr,)</p> <code>Lfh</code> <code>Array</code> <p>Lie derivative of <code>h</code> w.r.t. <code>f</code>, shape (num_barr,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def h_and_Lfh(  # pylint: disable=invalid-name\n    self, z: ArrayLike, *h_args\n) -&gt; Tuple[Array, Array]:\n    \"\"\"Lie derivative of the barrier function(s) wrt the autonomous dynamics `f(z)`\n\n    The evaluation of the barrier function is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        h (Array): Barrier function evaluation, shape (num_barr,)\n        Lfh (Array): Lie derivative of `h` w.r.t. `f`, shape (num_barr,)\n    \"\"\"\n    # Note: the below code is just a more efficient way of stating `Lfh = jax.jacobian(self.h)(z) @ self.f(z)`\n    # with the bonus benefit of also evaluating the barrier function\n\n    def _h(state):\n        return self.h(state, *h_args)\n\n    return jax.jvp(_h, (z,), (self.f(z),))\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.Lgh","title":"<code>Lgh(z, *h_args)</code>","text":"<p>Lie derivative of the barrier function(s) wrt the control dynamics <code>g(z)u</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Lgh, shape (num_barr, m)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def Lgh(self, z: ArrayLike, *h_args) -&gt; Array:  # pylint: disable=invalid-name\n    \"\"\"Lie derivative of the barrier function(s) wrt the control dynamics `g(z)u`\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Lgh, shape (num_barr, m)\n    \"\"\"\n    # Note: the below code is just a more efficient way of stating `Lgh = jax.jacobian(self.h)(z) @ self.g(z)`\n\n    def _h(state):\n        return self.h(state, *h_args)\n\n    def _jvp(g_column):\n        return jax.jvp(_h, (z,), (g_column,))[1]\n\n    return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.V","title":"<code>V(z, z_des)</code>","text":"<p>Control Lyapunov Function(s)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>CLF evaluation, shape (num_clf,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def V(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"Control Lyapunov Function(s)\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        z_des (ArrayLike): Desired state, shape (n,)\n\n    Returns:\n        Array: CLF evaluation, shape (num_clf,)\n    \"\"\"\n\n    def _V_2(state):\n        return self.V_2(state, z_des)\n\n    # Take any relative-degree-2 CLFs and convert them to relative-degree-1\n    # NOTE: If adding args to the CLF, create a wrapper func like with the barrier function\n    V_2, dV_2_dt = jax.jvp(_V_2, (z,), (self.f(z),))\n    V2_rd1 = dV_2_dt + self.gamma_2(V_2)\n\n    # Merge the relative-degree-1 and relative-degree-2 CLFs\n    return jnp.concatenate([self.V_1(z, z_des), V2_rd1])\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.V_and_LfV","title":"<code>V_and_LfV(z, z_des)</code>","text":"<p>Lie derivative of the CLF wrt the autonomous dynamics <code>f(z)</code></p> <p>The evaluation of the CLF is also returned \"for free\", a byproduct of the jacobian-vector-product</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>V</code> <code>Array</code> <p>CLF evaluation, shape (1,)</p> <code>LfV</code> <code>Array</code> <p>Lie derivative of <code>V</code> w.r.t. <code>f</code>, shape (1,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def V_and_LfV(self, z: ArrayLike, z_des: ArrayLike) -&gt; Tuple[Array, Array]:\n    \"\"\"Lie derivative of the CLF wrt the autonomous dynamics `f(z)`\n\n    The evaluation of the CLF is also returned \"for free\", a byproduct of the jacobian-vector-product\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        z_des (ArrayLike): Desired state, shape (n,)\n\n    Returns:\n        V (Array): CLF evaluation, shape (1,)\n        LfV (Array): Lie derivative of `V` w.r.t. `f`, shape (1,)\n    \"\"\"\n\n    def _V(state):\n        return self.V(state, z_des)\n\n    return jax.jvp(_V, (z,), (self.f(z),))\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.LgV","title":"<code>LgV(z, z_des)</code>","text":"<p>Lie derivative of the CLF wrt the control dynamics <code>g(z)u</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>LgV, shape (m,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def LgV(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"Lie derivative of the CLF wrt the control dynamics `g(z)u`\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        z_des (ArrayLike): Desired state, shape (n,)\n\n    Returns:\n        Array: LgV, shape (m,)\n    \"\"\"\n\n    def _V(state):\n        return self.V(state, z_des)\n\n    def _jvp(g_column):\n        return jax.jvp(_V, (z,), (g_column,))[1]\n\n    return jax.vmap(_jvp, in_axes=1, out_axes=1)(self.g(z))\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.P_qp","title":"<code>P_qp(z, z_des, *h_args)</code>","text":"<p>Quadratic term in the QP objective (<code>minimize 0.5 * x^T P x + q^T x</code>)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>P matrix, shape (m, m)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def P_qp(  # pylint: disable=invalid-name\n    self, z: Array, z_des: Array, *h_args\n) -&gt; Array:\n    \"\"\"Quadratic term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: P matrix, shape (m, m)\n    \"\"\"\n    return jnp.block(\n        [\n            [self.H(z), jnp.zeros((self.m, 1))],\n            [jnp.zeros((1, self.m)), jnp.atleast_1d(self.clf_relaxation_penalty)],\n        ]\n    )\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.q_qp","title":"<code>q_qp(z, z_des, *h_args)</code>","text":"<p>Linear term in the QP objective (<code>minimize 0.5 * x^T P x + q^T x</code>)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Q vector, shape (m,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def q_qp(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n    \"\"\"Linear term in the QP objective (`minimize 0.5 * x^T P x + q^T x`)\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: Q vector, shape (m,)\n    \"\"\"\n    return jnp.concatenate([self.F(z), jnp.array([0.0])])\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.G_qp","title":"<code>G_qp(z, z_des, *h_args)</code>","text":"<p>Inequality constraint matrix for the QP (<code>Gx &lt;= h</code>)</p> Note <p>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>G matrix, shape (num_constraints, m)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def G_qp(  # pylint: disable=invalid-name\n    self, z: Array, z_des: Array, *h_args\n) -&gt; Array:\n    \"\"\"Inequality constraint matrix for the QP (`Gx &lt;= h`)\n\n    Note:\n        The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: G matrix, shape (num_constraints, m)\n    \"\"\"\n    G = jnp.block(\n        [\n            [self.LgV(z, z_des), -1.0 * jnp.ones((self.num_clf, 1))],\n            [-self.Lgh(z, *h_args), jnp.zeros((self.num_cbf, 1))],\n        ]\n    )\n    if self.control_constrained:\n        return jnp.block(\n            [\n                [G],\n                [jnp.eye(self.m), jnp.zeros((self.m, 1))],\n                [-jnp.eye(self.m), jnp.zeros((self.m, 1))],\n            ]\n        )\n    else:\n        return G\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.h_qp","title":"<code>h_qp(z, z_des, *h_args)</code>","text":"<p>Upper bound on constraints for the QP (<code>Gx &lt;= h</code>)</p> Note <p>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>h vector, shape (num_constraints,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def h_qp(self, z: Array, z_des: Array, *h_args) -&gt; Array:\n    \"\"\"Upper bound on constraints for the QP (`Gx &lt;= h`)\n\n    Note:\n        The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: h vector, shape (num_constraints,)\n    \"\"\"\n    hz, lfh = self.h_and_Lfh(z, *h_args)\n    vz, lfv = self.V_and_LfV(z, z_des)\n    h = jnp.concatenate(\n        [\n            -lfv - self.gamma(vz),\n            self.alpha(hz) + lfh,\n        ]\n    )\n    if self.control_constrained:\n        return jnp.concatenate(\n            [h, jnp.asarray(self.u_max), -jnp.asarray(self.u_min)]\n        )\n    else:\n        return h\n</code></pre>"},{"location":"api/clf_cbf/#cbfpy.cbfs.clf_cbf.CLFCBF.qp_data","title":"<code>qp_data(z, z_des, *h_args)</code>","text":"<p>Constructs the QP matrices based on the current state and desired control</p> <p>i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:</p> <pre><code>minimize 0.5 * x^T P x + q^T x\nsubject to  A x == b\n            G x &lt;= h\n</code></pre> Note <ul> <li>CBFs do not rely on equality constraints, so <code>A</code> and <code>b</code> are empty.</li> <li>The number of constraints depends on if we have control constraints or not.     Without control constraints, <code>num_constraints == num_barriers</code>.     With control constraints, <code>num_constraints == num_barriers + 2*m</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>Array</code> <p>Desired state, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>P</code> <code>Array</code> <p>Quadratic term in the QP objective, shape (m + 1, m + 1)</p> <code>q</code> <code>Array</code> <p>Linear term in the QP objective, shape (m + 1,)</p> <code>A</code> <code>Array</code> <p>Equality constraint matrix, shape (0, m + 1)</p> <code>b</code> <code>Array</code> <p>Equality constraint vector, shape (0,)</p> <code>G</code> <code>Array</code> <p>Inequality constraint matrix, shape (num_constraints, m + 1)</p> <code>h</code> <code>Array</code> <p>Upper bound on constraints, shape (num_constraints,)</p> Source code in <code>cbfpy/cbfs/clf_cbf.py</code> <pre><code>def qp_data(\n    self, z: Array, z_des: Array, *h_args\n) -&gt; Tuple[Array, Array, Array, Array, Array, Array]:\n    \"\"\"Constructs the QP matrices based on the current state and desired control\n\n    i.e. the matrices/vectors (P, q, A, b, G, h) for the optimization problem:\n\n    ```\n    minimize 0.5 * x^T P x + q^T x\n    subject to  A x == b\n                G x &lt;= h\n    ```\n\n    Note:\n        - CBFs do not rely on equality constraints, so `A` and `b` are empty.\n        - The number of constraints depends on if we have control constraints or not.\n            Without control constraints, `num_constraints == num_barriers`.\n            With control constraints, `num_constraints == num_barriers + 2*m`\n\n    Args:\n        z (Array): State, shape (n,)\n        z_des (Array): Desired state, shape (n,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        P (Array): Quadratic term in the QP objective, shape (m + 1, m + 1)\n        q (Array): Linear term in the QP objective, shape (m + 1,)\n        A (Array): Equality constraint matrix, shape (0, m + 1)\n        b (Array): Equality constraint vector, shape (0,)\n        G (Array): Inequality constraint matrix, shape (num_constraints, m + 1)\n        h (Array): Upper bound on constraints, shape (num_constraints,)\n    \"\"\"\n    return (\n        self.P_qp(z, z_des, *h_args),\n        self.q_qp(z, z_des, *h_args),\n        jnp.zeros((0, self.m + 1)),  # Equality matrix (not used for CLF-CBF)\n        jnp.zeros(0),  # Equality vector (not used for CLF-CBF)\n        self.G_qp(z, z_des, *h_args),\n        self.h_qp(z, z_des, *h_args),\n    )\n</code></pre>"},{"location":"api/clf_cbf_config/","title":"CLF-CBF Config","text":""},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config--clf-cbf-configuration-class","title":"CLF-CBF Configuration class","text":""},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config--defining-the-problem","title":"Defining the problem:","text":"<p>As with the CBF, we require implementation of the dynamics functions <code>f</code> and <code>g</code>, as well as the barrier function(s) <code>h</code>. Now, with the CLF-CBF, we require the definition of the Control Lyapunov Function (CLF) <code>V</code>. This CLF must be a positive definite function of the state.</p> <p>Depending on the relative degree of your barrier function(s), you should implement the <code>h_1</code> method (for a relative-degree-1 barrier), and/or the <code>h_2</code> method (for a relative-degree-2 barrier).</p> <p>Likewise, for the CLF, you should implement the <code>V_1</code> method (for a relative-degree-1 CLF), and/or the <code>V_2</code> method (for a relative-degree-2 CLF).</p>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config--tuning-the-clf-cbf","title":"Tuning the CLF-CBF:","text":"<p>As with the CBF, the CLF-CBF config allows for adjustment of the class-Kappa CBF \"gain\" functions <code>alpha</code> and <code>alpha_2</code>. Additionally, the CLF-CBF config allows for adjustment of the class-Kappa CLF \"gain\" functions <code>gamma</code> and <code>gamma_2</code> (for relative-degree-2 CLFs).</p> <p>The CLF-CBF config also allows for adjustment of the quadratic control term <code>H</code> and the linear control term <code>F</code> in the CLF objective. These can be used to adjust the weightings between inputs, for instance.</p>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config--relaxation","title":"Relaxation:","text":"<p>If the CBF constraints are not necessarily globally feasible, you can enable further relaxation in the CLFCBFConfig. However, since the CLF constraint was already relaxed with respect to the CBF constraint, this means that tuning the relaxation parameters is critical. In general, the penalty on the CBF relaxation should be much higher than the penalty on the CLF relaxation.</p> <p>If strict enforcement of the CLF-CBF is desired, your higest-level controller should handle the case where the QP is infeasible.</p>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig","title":"<code>CLFCBFConfig</code>","text":"<p>               Bases: <code>CBFConfig</code></p> <p>Control Lyapunov Function / Control Barrier Function (CLF-CBF) configuration class.</p> <p>This is an abstract class which requires implementation of the following methods:</p> <ul> <li><code>f(z)</code>: The uncontrolled dynamics function</li> <li><code>g(z)</code>: The control affine dynamics function</li> <li><code>h_1(z)</code> and/or <code>h_2(z)</code>: The barrier function(s), of relative degree 1 and/or 2</li> <li><code>V_1(z)</code> and/or <code>V_2(z)</code>: The Lyapunov function(s), of relative degree 1 and/or 2</li> </ul> <p>For finer-grained control over the CLF-CBF, the following methods may be updated from their defaults:</p> <ul> <li><code>alpha(h)</code>: \"Gain\" of the CBF</li> <li><code>alpha_2(h_2)</code>: \"Gain\" of the relative-degree-2 CBFs, if applicable</li> <li><code>gamma(v)</code>: \"Gain\" of the CLF</li> <li><code>gamma_2(v)</code>: \"Gain\" of the relative-degree-2 CLFs, if applicable</li> <li><code>H(z)</code>: Quadratic control term in the CLF objective</li> <li><code>F(z)</code>: Linear control term in the CLF objective</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>State dimension</p> required <code>m</code> <code>int</code> <p>Control dimension</p> required <code>u_min</code> <code>ArrayLike</code> <p>Minimum control input, shape (m,). Defaults to None (Unconstrained).</p> <code>None</code> <code>u_max</code> <code>ArrayLike</code> <p>Maximum control input, shape (m,). Defaults to None (Unconstrained).</p> <code>None</code> <code>relax_qp</code> <code>bool</code> <p>Whether to allow for relaxation in the CLF-CBF QP. Defaults to True. Note: this is required for differentiability through the QP.</p> <code>True</code> <code>cbf_relaxation_penalty</code> <code>float</code> <p>Penalty on the slack variable in the relaxed QP. Defaults to 1e4. Note: only applies if relax_qp is True.</p> <code>10000.0</code> <code>clf_relaxation_penalty</code> <code>float</code> <p>Penalty on the CLF slack variable when enforcing the CBF. Defaults to 1e2</p> <code>100.0</code> <code>control_relaxation_penalty</code> <code>float</code> <p>Penalty on the control constraint slack variables in the relaxed QP. Defaults to 1e5. Note: only applies if relax_qp is True.</p> <code>100000.0</code> <code>solver_tol</code> <code>float</code> <p>Tolerance for the QP solver. Defaults to 1e-3.</p> <code>0.001</code> <code>init_args</code> <code>tuple</code> <p>If your barrier function relies on additional arguments other than just the state, include an initial seed for these arguments here. This is to help test the output of the barrier function. Defaults to ().</p> <code>()</code> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>class CLFCBFConfig(CBFConfig):\n    \"\"\"Control Lyapunov Function / Control Barrier Function (CLF-CBF) configuration class.\n\n    This is an abstract class which requires implementation of the following methods:\n\n    - `f(z)`: The uncontrolled dynamics function\n    - `g(z)`: The control affine dynamics function\n    - `h_1(z)` and/or `h_2(z)`: The barrier function(s), of relative degree 1 and/or 2\n    - `V_1(z)` and/or `V_2(z)`: The Lyapunov function(s), of relative degree 1 and/or 2\n\n    For finer-grained control over the CLF-CBF, the following methods may be updated from their defaults:\n\n    - `alpha(h)`: \"Gain\" of the CBF\n    - `alpha_2(h_2)`: \"Gain\" of the relative-degree-2 CBFs, if applicable\n    - `gamma(v)`: \"Gain\" of the CLF\n    - `gamma_2(v)`: \"Gain\" of the relative-degree-2 CLFs, if applicable\n    - `H(z)`: Quadratic control term in the CLF objective\n    - `F(z)`: Linear control term in the CLF objective\n\n    Args:\n        n (int): State dimension\n        m (int): Control dimension\n        u_min (ArrayLike, optional): Minimum control input, shape (m,). Defaults to None (Unconstrained).\n        u_max (ArrayLike, optional): Maximum control input, shape (m,). Defaults to None (Unconstrained).\n        relax_qp (bool, optional): Whether to allow for relaxation in the CLF-CBF QP. Defaults to True.\n            Note: this is required for differentiability through the QP.\n        cbf_relaxation_penalty (float, optional): Penalty on the slack variable in the relaxed QP. Defaults to 1e4.\n            Note: only applies if relax_qp is True.\n        clf_relaxation_penalty (float): Penalty on the CLF slack variable when enforcing the CBF. Defaults to 1e2\n        control_relaxation_penalty (float, optional): Penalty on the control constraint slack variables in the\n            relaxed QP. Defaults to 1e5. Note: only applies if relax_qp is True.\n        solver_tol (float, optional): Tolerance for the QP solver. Defaults to 1e-3.\n        init_args (tuple, optional): If your barrier function relies on additional arguments other than just the state,\n            include an initial seed for these arguments here. This is to help test the output of the barrier function.\n            Defaults to ().\n    \"\"\"\n\n    def __init__(\n        self,\n        n: int,\n        m: int,\n        u_min: Optional[ArrayLike] = None,\n        u_max: Optional[ArrayLike] = None,\n        relax_qp: bool = True,\n        cbf_relaxation_penalty: float = 1e4,\n        clf_relaxation_penalty: float = 1e2,\n        control_relaxation_penalty: float = 1e5,\n        solver_tol: float = 1e-3,\n        init_args: tuple = (),\n    ):\n        super().__init__(\n            n,\n            m,\n            u_min,\n            u_max,\n            relax_qp,\n            cbf_relaxation_penalty,\n            control_relaxation_penalty,\n            solver_tol,\n            init_args,\n        )\n\n        if not (\n            isinstance(clf_relaxation_penalty, (int, float))\n            and clf_relaxation_penalty &gt; 0\n        ):\n            raise ValueError(\n                f\"Invalid clf_relaxation_penalty: {clf_relaxation_penalty}. Must be a positive value.\"\n            )\n        self.clf_relaxation_penalty = float(clf_relaxation_penalty)\n\n        # If relaxing the QP, need to have CLF penalty &lt; CBF penalty &lt; Control constraint penalty\n        if self.cbf_relaxation_penalty &lt; self.clf_relaxation_penalty:\n            print(\"WARNING: CBF constraints have a lower penalty than the CLFs\")\n        if (\n            self.control_constrained\n            and self.control_relaxation_penalty &lt; self.clf_relaxation_penalty\n        ):\n            print(\"WARNING: Control constraints have a lower penalty than the CLFs\")\n\n        # Check on CLF dimension\n        z_test = jnp.ones(self.n)\n        v1_test = self.V_1(z_test, z_test)\n        v2_test = self.V_2(z_test, z_test)\n        if v1_test.ndim != 1 or v2_test.ndim != 1:\n            raise ValueError(\"CLF(s) must output 1D arrays\")\n        self.num_rd1_clf = v1_test.shape[0]\n        self.num_rd2_clf = v2_test.shape[0]\n        self.num_clf = self.num_rd1_clf + self.num_rd2_clf\n        if self.num_clf == 0:\n            raise ValueError(\n                \"No Lyanpunov functions provided.\"\n                + \"\\nYou can implement this via the V_1 and/or V_2 methods in your config class\"\n            )\n        v_test = jnp.concatenate([v1_test, v2_test])\n        gamma_test = self.gamma(v_test)\n        gamma_2_test = self.gamma_2(v2_test)\n        if gamma_test.shape != (self.num_clf,):\n            raise ValueError(\n                f\"Invalid shape for gamma(V(z)): {gamma_test.shape}. Expected ({self.num_clf},)\"\n                + \"\\nCheck that the output of the gamma() function matches the number of CLFs\"\n            )\n        if gamma_2_test.shape != (self.num_rd2_clf,):\n            raise ValueError(\n                f\"Invalid shape for gamma_2(V_2(z)): {gamma_2_test.shape}. Expected ({self.num_rd2_clf},)\"\n                + \"\\nCheck that the output of the gamma_2() function matches the number of RD2 CLFs\"\n            )\n        self._check_class_kappa(self.gamma, self.num_clf)\n        self._check_class_kappa(self.gamma_2, self.num_rd2_clf)\n        H_test = self.H(z_test)\n        if H_test.shape != (self.m, self.m):\n            raise ValueError(\n                f\"Invalid shape for H(z): {H_test.shape}. Expected ({self.m}, {self.m})\"\n            )\n        if not self._is_symmetric_psd(H_test):\n            raise ValueError(\"H(z) must be symmetric positive semi-definite\")\n\n        # Handle QP relaxation penalties, if relaxation is enabled\n        num_qp_constraints = (\n            self.num_cbf + self.num_clf\n            if not self.control_constrained\n            else self.num_cbf + self.num_clf + 2 * self.m\n        )\n        if self.control_constrained:\n            self.constraint_relaxation_penalties = tuple(\n                np.concatenate(\n                    [\n                        self.clf_relaxation_penalty * np.ones(self.num_clf),\n                        self.cbf_relaxation_penalty * np.ones(self.num_cbf),\n                        self.control_relaxation_penalty * np.ones(2 * self.m),\n                    ]\n                )\n            )\n        else:\n            self.constraint_relaxation_penalties = tuple(\n                np.concatenate(\n                    [\n                        self.clf_relaxation_penalty * np.ones(self.num_clf),\n                        self.cbf_relaxation_penalty * np.ones(self.num_cbf),\n                    ]\n                )\n            )\n        assert len(self.constraint_relaxation_penalties) == num_qp_constraints\n\n    def V_1(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n        \"\"\"Relative-Degree-1 Control Lyapunov Function (CLF)\n\n        A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is\n        such that there exists a control input u which makes the time-derivative of the CLF negative.\n\n        Relative degree can generally be thought of as the number of integrations required between the\n        input and output of the system. For instance, a (relative-degree-1) CLF based on velocities,\n        with acceleration inputs, will be directly modified on the next timestep.\n\n        At least one of `V_1` or `V_2` must be implemented. Multiple CLFs is possible, but generally, these cannot all\n        be strictly enforced.\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            z_des (ArrayLike): Desired state, shape (n,)\n\n        Returns:\n            Array: V(z): The RD1 CLF evaluation, shape (num_rd1_clf,)\n        \"\"\"\n        return jnp.array([])\n\n    # TODO: Check if the math behind this is actually valid\n    def V_2(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n        \"\"\"Relative-Degree-2 (high-order) Control Lyapunov Function (CLF)\n\n        A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is\n        such that there exists a control input u which makes the time-derivative of the CLF negative.\n\n        Relative degree can generally be thought of as the number of integrations required between the\n        input and output of the system. For instance, a (relative-degree-2) CLF based on position,\n        with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity,\n        which then changes the position.\n\n        At least one of `V_1` or `V_2` must be implemented. Multiple CLFs is possible, but generally, these cannot all\n        be strictly enforced.\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n            z_des (ArrayLike): Desired state, shape (n,)\n\n        Returns:\n            Array: V(z): The RD2 CLF evaluation, shape (num_rd2_clf,)\n        \"\"\"\n        return jnp.array([])\n\n    def gamma(self, v: ArrayLike) -&gt; Array:\n        \"\"\"A class Kappa function, dictating the \"gain\" of the CLF\n\n        For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n\n        The default implementation can be overridden for more fine-grained control over the CLF\n\n        Args:\n            v (ArrayLike): Evaluation of the CLF(s) at the current state, shape (num_clf,).\n\n        Returns:\n            Array: gamma(V(z)), shape (num_clf,).\n        \"\"\"\n        return v\n\n    def gamma_2(self, v_2: ArrayLike) -&gt; Array:\n        \"\"\"A second class Kappa function, dictating the \"gain\" associated with the derivative of the CLF\n\n        For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n\n        The default implementation can be overridden for more fine-grained control over the CLF\n\n        Args:\n            v_2 (ArrayLike): Evaluation of the RD2 CLF(s) at the current state, shape (num_rd2_clf,)\n\n        Returns:\n            Array: gamma_2(V_2(z)), shape (num_rd2_clf,)\n        \"\"\"\n        return v_2\n\n    def H(self, z: ArrayLike) -&gt; Array:\n        \"\"\"Matrix defining the quadratic control term in the CLF objective (minimize 0.5 * u^T H u + F^T u)\n\n        **Must be PSD!**\n\n        The default implementation is just the (m x m) identity matrix, but this can be overridden\n        for more fine-grained control over the objective\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n\n        Returns:\n            Array: H, shape (m, m)\n        \"\"\"\n        return jnp.eye(self.m)\n\n    def F(self, z: ArrayLike) -&gt; Array:\n        \"\"\"Vector defining the linear term in the CLF objective (minimize 0.5 * u^T H u + F^T u)\n\n        The default implementation is a zero vector, but this can be overridden\n        for more fine-grained control over the objective\n\n        Args:\n            z (ArrayLike): State, shape (n,)\n\n        Returns:\n            Array: F, shape (m,)\n        \"\"\"\n        return jnp.zeros(self.m)\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.V_1","title":"<code>V_1(z, z_des)</code>","text":"<p>Relative-Degree-1 Control Lyapunov Function (CLF)</p> <p>A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is such that there exists a control input u which makes the time-derivative of the CLF negative.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-1) CLF based on velocities, with acceleration inputs, will be directly modified on the next timestep.</p> <p>At least one of <code>V_1</code> or <code>V_2</code> must be implemented. Multiple CLFs is possible, but generally, these cannot all be strictly enforced.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>V(z): The RD1 CLF evaluation, shape (num_rd1_clf,)</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def V_1(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"Relative-Degree-1 Control Lyapunov Function (CLF)\n\n    A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is\n    such that there exists a control input u which makes the time-derivative of the CLF negative.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-1) CLF based on velocities,\n    with acceleration inputs, will be directly modified on the next timestep.\n\n    At least one of `V_1` or `V_2` must be implemented. Multiple CLFs is possible, but generally, these cannot all\n    be strictly enforced.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        z_des (ArrayLike): Desired state, shape (n,)\n\n    Returns:\n        Array: V(z): The RD1 CLF evaluation, shape (num_rd1_clf,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.V_2","title":"<code>V_2(z, z_des)</code>","text":"<p>Relative-Degree-2 (high-order) Control Lyapunov Function (CLF)</p> <p>A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is such that there exists a control input u which makes the time-derivative of the CLF negative.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-2) CLF based on position, with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity, which then changes the position.</p> <p>At least one of <code>V_1</code> or <code>V_2</code> must be implemented. Multiple CLFs is possible, but generally, these cannot all be strictly enforced.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>z_des</code> <code>ArrayLike</code> <p>Desired state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>V(z): The RD2 CLF evaluation, shape (num_rd2_clf,)</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def V_2(self, z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"Relative-Degree-2 (high-order) Control Lyapunov Function (CLF)\n\n    A CLF is a positive-definite function which evaluates to zero at the equilibrium point, and is\n    such that there exists a control input u which makes the time-derivative of the CLF negative.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-2) CLF based on position,\n    with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity,\n    which then changes the position.\n\n    At least one of `V_1` or `V_2` must be implemented. Multiple CLFs is possible, but generally, these cannot all\n    be strictly enforced.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        z_des (ArrayLike): Desired state, shape (n,)\n\n    Returns:\n        Array: V(z): The RD2 CLF evaluation, shape (num_rd2_clf,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.gamma","title":"<code>gamma(v)</code>","text":"<p>A class Kappa function, dictating the \"gain\" of the CLF</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin.</p> <p>The default implementation can be overridden for more fine-grained control over the CLF</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ArrayLike</code> <p>Evaluation of the CLF(s) at the current state, shape (num_clf,).</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>gamma(V(z)), shape (num_clf,).</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def gamma(self, v: ArrayLike) -&gt; Array:\n    \"\"\"A class Kappa function, dictating the \"gain\" of the CLF\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n\n    The default implementation can be overridden for more fine-grained control over the CLF\n\n    Args:\n        v (ArrayLike): Evaluation of the CLF(s) at the current state, shape (num_clf,).\n\n    Returns:\n        Array: gamma(V(z)), shape (num_clf,).\n    \"\"\"\n    return v\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.gamma_2","title":"<code>gamma_2(v_2)</code>","text":"<p>A second class Kappa function, dictating the \"gain\" associated with the derivative of the CLF</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin.</p> <p>The default implementation can be overridden for more fine-grained control over the CLF</p> <p>Parameters:</p> Name Type Description Default <code>v_2</code> <code>ArrayLike</code> <p>Evaluation of the RD2 CLF(s) at the current state, shape (num_rd2_clf,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>gamma_2(V_2(z)), shape (num_rd2_clf,)</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def gamma_2(self, v_2: ArrayLike) -&gt; Array:\n    \"\"\"A second class Kappa function, dictating the \"gain\" associated with the derivative of the CLF\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n\n    The default implementation can be overridden for more fine-grained control over the CLF\n\n    Args:\n        v_2 (ArrayLike): Evaluation of the RD2 CLF(s) at the current state, shape (num_rd2_clf,)\n\n    Returns:\n        Array: gamma_2(V_2(z)), shape (num_rd2_clf,)\n    \"\"\"\n    return v_2\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.H","title":"<code>H(z)</code>","text":"<p>Matrix defining the quadratic control term in the CLF objective (minimize 0.5 * u^T H u + F^T u)</p> <p>Must be PSD!</p> <p>The default implementation is just the (m x m) identity matrix, but this can be overridden for more fine-grained control over the objective</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>H, shape (m, m)</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def H(self, z: ArrayLike) -&gt; Array:\n    \"\"\"Matrix defining the quadratic control term in the CLF objective (minimize 0.5 * u^T H u + F^T u)\n\n    **Must be PSD!**\n\n    The default implementation is just the (m x m) identity matrix, but this can be overridden\n    for more fine-grained control over the objective\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n\n    Returns:\n        Array: H, shape (m, m)\n    \"\"\"\n    return jnp.eye(self.m)\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.F","title":"<code>F(z)</code>","text":"<p>Vector defining the linear term in the CLF objective (minimize 0.5 * u^T H u + F^T u)</p> <p>The default implementation is a zero vector, but this can be overridden for more fine-grained control over the objective</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>F, shape (m,)</p> Source code in <code>cbfpy/config/clf_cbf_config.py</code> <pre><code>def F(self, z: ArrayLike) -&gt; Array:\n    \"\"\"Vector defining the linear term in the CLF objective (minimize 0.5 * u^T H u + F^T u)\n\n    The default implementation is a zero vector, but this can be overridden\n    for more fine-grained control over the objective\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n\n    Returns:\n        Array: F, shape (m,)\n    \"\"\"\n    return jnp.zeros(self.m)\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.f","title":"<code>f(z)</code>  <code>abstractmethod</code>","text":"<p>The uncontrolled dynamics function. Possibly nonlinear, and locally Lipschitz</p> <p>i.e. the function f, such that z_dot = f(z) + g(z) u</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Uncontrolled state derivative component, shape (n,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>@abstractmethod\ndef f(self, z: ArrayLike) -&gt; Array:\n    \"\"\"The uncontrolled dynamics function. Possibly nonlinear, and locally Lipschitz\n\n    i.e. the function f, such that z_dot = f(z) + g(z) u\n\n    Args:\n        z (ArrayLike): The state, shape (n,)\n\n    Returns:\n        Array: Uncontrolled state derivative component, shape (n,)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.g","title":"<code>g(z)</code>  <code>abstractmethod</code>","text":"<p>The control affine dynamics function. Locally Lipschitz.</p> <p>i.e. the function g, such that z_dot = f(z) + g(z) u</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The state, shape (n,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Control matrix, shape (n, m)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>@abstractmethod\ndef g(self, z: ArrayLike) -&gt; Array:\n    \"\"\"The control affine dynamics function. Locally Lipschitz.\n\n    i.e. the function g, such that z_dot = f(z) + g(z) u\n\n    Args:\n        z (ArrayLike): The state, shape (n,)\n\n    Returns:\n        Array: Control matrix, shape (n, m)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.h_1","title":"<code>h_1(z, *h_args)</code>","text":"<p>Relative-degree-1 barrier function(s).</p> <p>A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-1) CBF based on velocities, with acceleration inputs, will be directly modified on the next timestep.</p> <p>If your barrier function is relative-degree-2, or if you would like to enforce additional barriers which are relative-degree-2, use the <code>h_2</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function. Note: If using additional args with your barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function(s), shape (num_rd1_barr,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def h_1(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Relative-degree-1 barrier function(s).\n\n    A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n    the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-1) CBF based on velocities,\n    with acceleration inputs, will be directly modified on the next timestep.\n\n    If your barrier function is relative-degree-2, or if you would like to enforce additional barriers\n    which are relative-degree-2, use the `h_2` method.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n            barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n    Returns:\n        Array: Barrier function(s), shape (num_rd1_barr,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.h_2","title":"<code>h_2(z, *h_args)</code>","text":"<p>Relative-degree-2 (high-order) barrier function(s).</p> <p>A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.</p> <p>Relative degree can generally be thought of as the number of integrations required between the input and output of the system. For instance, a (relative-degree-2) CBF based on position, with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity, which then changes the position.</p> <p>If your barrier function is relative-degree-1, or if you would like to enforce additional barriers which are relative-degree-1, use the <code>h_1</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>State, shape (n,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function. Note: If using additional args with your barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Barrier function(s), shape (num_rd2_barr,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def h_2(self, z: ArrayLike, *h_args) -&gt; Array:\n    \"\"\"Relative-degree-2 (high-order) barrier function(s).\n\n    A (zeroing) CBF is a continuously-differentiable function h, such that for any state z in the interior of\n    the safe set, h(z) should be &gt; 0, and h(z) = 0 on the boundary. When in the unsafe set, h(z) &lt; 0.\n\n    Relative degree can generally be thought of as the number of integrations required between the\n    input and output of the system. For instance, a (relative-degree-2) CBF based on position,\n    with acceleration inputs, will be modified in two timesteps: the acceleration changes the velocity,\n    which then changes the position.\n\n    If your barrier function is relative-degree-1, or if you would like to enforce additional barriers\n    which are relative-degree-1, use the `h_1` method.\n\n    Args:\n        z (ArrayLike): State, shape (n,)\n        *h_args: Optional additional arguments for the barrier function. Note: If using additional args with your\n            barrier, these must be a static shape/type, or else this will trigger a recompilation in Jax.\n\n    Returns:\n        Array: Barrier function(s), shape (num_rd2_barr,)\n    \"\"\"\n    return jnp.array([])\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.alpha","title":"<code>alpha(h)</code>","text":"<p>A class Kappa function, dictating the \"gain\" of the barrier function(s)</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin. A simple example is alpha(h) = h</p> <p>The default implementation can be overridden for more fine-grained control over the CBF</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>ArrayLike</code> <p>Evaluation of the barrier function(s) at the current state, shape (num_cbf,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>alpha(h(z)), shape (num_cbf,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def alpha(self, h: ArrayLike) -&gt; Array:\n    \"\"\"A class Kappa function, dictating the \"gain\" of the barrier function(s)\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n    A simple example is alpha(h) = h\n\n    The default implementation can be overridden for more fine-grained control over the CBF\n\n    Args:\n        h (ArrayLike): Evaluation of the barrier function(s) at the current state, shape (num_cbf,)\n\n    Returns:\n        Array: alpha(h(z)), shape (num_cbf,)\n    \"\"\"\n    return h\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.alpha_2","title":"<code>alpha_2(h_2)</code>","text":"<p>A second class Kappa function which dictactes the \"gain\" associated with the relative-degree-2 barrier functions</p> <p>For reference, a class Kappa function is a monotonically increasing function which passes through the origin. A simple example is alpha_2(h_2) = h_2</p> <p>The default implementation can be overridden for more fine-grained control over the CBF</p> <p>Parameters:</p> Name Type Description Default <code>h_2</code> <code>ArrayLike</code> <p>Evaluation of the RD2 barrier function(s) at the current state, shape (num_rd2_cbf,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>alpha_2(h_2(z)), shape (num_rd2_cbf,).</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def alpha_2(self, h_2: ArrayLike) -&gt; Array:\n    \"\"\"A second class Kappa function which dictactes the \"gain\" associated with the relative-degree-2\n    barrier functions\n\n    For reference, a class Kappa function is a monotonically increasing function which passes through the origin.\n    A simple example is alpha_2(h_2) = h_2\n\n    The default implementation can be overridden for more fine-grained control over the CBF\n\n    Args:\n        h_2 (ArrayLike): Evaluation of the RD2 barrier function(s) at the current state, shape (num_rd2_cbf,)\n\n    Returns:\n        Array: alpha_2(h_2(z)), shape (num_rd2_cbf,).\n    \"\"\"\n    return h_2\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.P","title":"<code>P(z, u_des, *h_args)</code>","text":"<p>Quadratic term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)</p> <p>This defaults to 2 * I, which is the value of P when minimizing the standard CBF objective, ||u - u_des||_{2}^{2}</p> <p>To change the objective, override this method. Note that P must be PSD</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>P matrix, shape (m, m)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def P(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Quadratic term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n    This defaults to 2 * I, which is the value of P when minimizing the standard CBF objective,\n    ||u - u_des||_{2}^{2}\n\n    To change the objective, override this method. **Note that P must be PSD**\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: P matrix, shape (m, m)\n    \"\"\"\n    return 2 * jnp.eye(self.m)\n</code></pre>"},{"location":"api/clf_cbf_config/#cbfpy.config.clf_cbf_config.CLFCBFConfig.q","title":"<code>q(z, u_des, *h_args)</code>","text":"<p>Linear term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)</p> <p>This defaults to -2 * u_des, which is the value of q when minimizing the standard CBF objective, ||u - u_des||_{2}^{2}</p> <p>To change the objective, override this method.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Array</code> <p>State, shape (n,)</p> required <code>u_des</code> <code>Array</code> <p>Desired control input, shape (m,)</p> required <code>*h_args</code> <p>Optional additional arguments for the barrier function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>q vector, shape (m,)</p> Source code in <code>cbfpy/config/cbf_config.py</code> <pre><code>def q(self, z: Array, u_des: Array, *h_args) -&gt; Array:\n    \"\"\"Linear term in the CBF QP objective (minimize 0.5 * x^T P x + q^T x)\n\n    This defaults to -2 * u_des, which is the value of q when minimizing the standard CBF objective,\n    ||u - u_des||_{2}^{2}\n\n    To change the objective, override this method.\n\n    Args:\n        z (Array): State, shape (n,)\n        u_des (Array): Desired control input, shape (m,)\n        *h_args: Optional additional arguments for the barrier function.\n\n    Returns:\n        Array: q vector, shape (m,)\n    \"\"\"\n    return -2 * u_des\n</code></pre>"},{"location":"api/drone_demo/","title":"Drone Obstacle Avoidance","text":""},{"location":"api/drone_demo/#cbfpy.examples.drone_demo","title":"<code>cbfpy.examples.drone_demo</code>","text":""},{"location":"api/drone_demo/#cbfpy.examples.drone_demo--drone-obstacle-avoidance-demo","title":"Drone Obstacle Avoidance Demo","text":"<p>We use velocity control, which can be easily applied to other drones (for instance, PX4-controlled quadrotors can take in velocity commands)</p> <p>The CBF uses a reduced model of the drone dynamics, while the simulation environment does reflect a (somewhat-accurate) model of the true drone dynamics</p> <p>Here, our state is the position and velocity of the drone: z = [position, velocity] and the control input is the velocity of the drone: u = [velocity]</p> <p>We also incorporate the state of the obstacle as an additional input to the CBF: z_obs = [position, velocity]</p> <p>Note: since there is gravity in this simulation, the obstacle will fall to the ground initially. This is fine: just use the mouse to drag it around near the drone to see the CBF response</p> <p>See https://danielpmorton.github.io/drone_fencing/ for a demo of this on real hardware, and see the \"point robot obstacle avoidance\" demo in CBFpy for a simplified version of this demo</p>"},{"location":"api/drone_demo/#cbfpy.examples.drone_demo.DroneConfig","title":"<code>DroneConfig</code>","text":"<p>               Bases: <code>CBFConfig</code></p> <p>Config for the drone obstacle avoidance / safe set containment demo</p> Source code in <code>cbfpy/examples/drone_demo.py</code> <pre><code>class DroneConfig(CBFConfig):\n    \"\"\"Config for the drone obstacle avoidance / safe set containment demo\"\"\"\n\n    def __init__(self):\n        self.mass = 1.0\n        self.pos_min = jnp.array([-2.0, -2.0, 0.7])\n        self.pos_max = jnp.array([2.0, 2.0, 2.0])\n        init_z_obs = jnp.array([3.0, 1.0, 1.0, -0.1, -0.1, -0.1])\n        super().__init__(\n            n=6,  # State = [position, velocity]\n            m=3,  # Control = [velocity]\n            relax_qp=True,\n            init_args=(init_z_obs,),\n            cbf_relaxation_penalty=1e6,\n        )\n\n    def f(self, z):\n        # Assume we are directly controlling the robot's velocity\n        return jnp.zeros(self.n)\n\n    def g(self, z):\n        # Assume we are directly controlling the robot's velocity\n        return jnp.block([[jnp.eye(3)], [jnp.zeros((3, 3))]])\n\n    def h_1(self, z, z_obs):\n        obstacle_radius = 0.25\n        robot_radius = 0.25\n        padding = 0.1\n        pos_robot = z[:3]\n        vel_robot = z[3:]\n        pos_obs = z_obs[:3]\n        vel_obs = z_obs[3:]\n        dist_between_centers = jnp.linalg.norm(pos_obs - pos_robot)\n        dir_obs_to_robot = (pos_robot - pos_obs) / dist_between_centers\n        collision_velocity_component = (vel_obs - vel_robot).T @ dir_obs_to_robot\n        lookahead_time = 2.0\n        padding = 0.1\n        h_obstacle_avoidance = jnp.array(\n            [\n                dist_between_centers\n                - collision_velocity_component * lookahead_time\n                - obstacle_radius\n                - robot_radius\n                - padding\n            ]\n        )\n        h_box_containment = jnp.concatenate(\n            [self.pos_max - z[:3], z[:3] - self.pos_min]\n        )\n        return jnp.concatenate([h_obstacle_avoidance, h_box_containment])\n\n    def alpha(self, h):\n        return jnp.array([3.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]) * h\n</code></pre>"},{"location":"api/drone_env/","title":"Drone Env","text":""},{"location":"api/drone_env/#cbfpy.envs.drone_env","title":"<code>cbfpy.envs.drone_env</code>","text":""},{"location":"api/drone_env/#cbfpy.envs.drone_env--drone-environment","title":"Drone Environment","text":"<p>This is a wrapper around the gym-pybullet-drones environment, using velocity control.</p>"},{"location":"api/drone_env/#cbfpy.envs.drone_env.DroneEnv","title":"<code>DroneEnv</code>","text":"<p>               Bases: <code>BaseEnv</code></p> <p>Drone Environment class</p> <p>This provides an environment where the drone is contained to lie within a safe box, and must avoid a movable obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>xyz_min</code> <code>ArrayLike</code> <p>Minimum bounds of the safe region, shape (3,)</p> <code>(-0.5, -0.5, 0.5)</code> <code>xyz_max</code> <code>ArrayLike</code> <p>Maximum bounds of the safe region, shape (3,)</p> <code>(0.5, 0.5, 1.5)</code> Source code in <code>cbfpy/envs/drone_env.py</code> <pre><code>class DroneEnv(BaseEnv):\n    \"\"\"Drone Environment class\n\n    This provides an environment where the drone is contained to lie within a safe box,\n    and must avoid a movable obstacle.\n\n    Args:\n        xyz_min (ArrayLike): Minimum bounds of the safe region, shape (3,)\n        xyz_max (ArrayLike): Maximum bounds of the safe region, shape (3,)\n    \"\"\"\n\n    # Constants\n    RADIUS = 0.1  # TODO tune\n\n    def __init__(\n        self,\n        xyz_min: ArrayLike = (-0.5, -0.5, 0.5),\n        xyz_max: ArrayLike = (0.5, 0.5, 1.5),\n    ):\n        # Suppress pybullet output + a Gym warning about float32 precision\n        with stdout_redirected(restore=False):\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                self._env = VelocityAviary(\n                    # drone_model=\"cf2x\",\n                    num_drones=1,\n                    initial_xyzs=np.array([[0, 0, 1]]),\n                    initial_rpys=np.array([[0, 0, 0]]),\n                    # physics=\"pyb\",\n                    neighbourhood_radius=np.inf,\n                    pyb_freq=240,\n                    ctrl_freq=48,\n                    gui=True,\n                    record=False,\n                    obstacles=False,\n                    user_debug_gui=False,\n                )\n            # Hack: Create same client interface as other envs\n            self.client: pybullet = object.__new__(BulletClient)\n            self.client._client = self._env.CLIENT\n        self.xyz_min = np.array(xyz_min)\n        self.xyz_max = np.array(xyz_max)\n        assert len(self.xyz_min) == len(self.xyz_max) == 3\n        self.client.setAdditionalSearchPath(find_assets_dir())\n        self.obstacle = self.client.loadURDF(\"point_robot.urdf\", basePosition=(1, 1, 1))\n        self.client.configureDebugVisualizer(self.client.COV_ENABLE_GUI, 0)\n        self.client.resetDebugVisualizerCamera(1.80, 37.60, -25.00, (0.05, 0.03, 0.75))\n        self.robot = self._env.DRONE_IDS[0]\n        self.client.changeVisualShape(self.obstacle, -1, rgbaColor=[1, 0, 0, 1])\n        self.client.changeDynamics(self.obstacle, -1, angularDamping=10)\n        self.box = visualize_3D_box(\n            [self.xyz_min - self.RADIUS, self.xyz_max + self.RADIUS],\n            rgba=(0, 1, 0, 0.5),\n        )\n        # For color determination\n        self.is_in_box = True\n        self.tol = 1e-3\n\n        self.action = np.array([[0.0, 0.0, 0.0, 0.0]])\n        self.obs, self.reward, self.terminated, self.truncated, self.info = (\n            self._env.step(self.action)\n        )\n\n    def _update_color(self, robot_pos: ArrayLike) -&gt; None:\n        \"\"\"Update the color of the box depending on if the robot is inside or not (Green inside, red outside)\"\"\"\n        robot_pos = np.array(robot_pos)\n        if np.any(robot_pos &lt; self.xyz_min - self.tol) or np.any(\n            robot_pos &gt; self.xyz_max + self.tol\n        ):\n            if self.is_in_box:\n                self.client.changeVisualShape(self.box, -1, rgbaColor=[1, 0, 0, 0.5])\n            self.is_in_box = False\n        else:\n            if not self.is_in_box:\n                self.client.changeVisualShape(self.box, -1, rgbaColor=[0, 1, 0, 0.5])\n            self.is_in_box = True\n\n    def get_state(self) -&gt; Array:\n        robot_pos = self.client.getBasePositionAndOrientation(self.robot)[0]\n        robot_vel = self.client.getBaseVelocity(self.robot)[0]\n        self._update_color(robot_pos)\n        obstacle_pos = self.client.getBasePositionAndOrientation(self.obstacle)[0]\n        obstacle_vel = self.client.getBaseVelocity(self.obstacle)[0]\n        return np.array([*robot_pos, *robot_vel]), np.array(\n            [*obstacle_pos, *obstacle_vel]\n        )\n\n    def get_desired_state(self) -&gt; Array:\n        return np.array([0, 0, 1, 0, 0, 0])\n\n    def apply_control(self, u: Array) -&gt; None:\n        # Note: the gym-pybullet-drones API has a weird format for the \"velocity action\" to take\n        self.action = np.array([[*u, np.linalg.norm(u)]])\n\n    def step(self):\n        # Step the gym-pybullet-drones environment using the last stored action\n        self.obs, self.reward, self.terminated, self.truncated, self.info = (\n            self._env.step(self.action)\n        )\n</code></pre>"},{"location":"api/joint_limits_demo/","title":"Manipulator Joint Limits","text":""},{"location":"api/joint_limits_demo/#cbfpy.examples.joint_limits_demo","title":"<code>cbfpy.examples.joint_limits_demo</code>","text":""},{"location":"api/joint_limits_demo/#cbfpy.examples.joint_limits_demo--manipulator-joint-limit-avoidance-demo","title":"Manipulator Joint Limit Avoidance Demo","text":"<p>We will command a joint position trajectory that exceeds the joint limits, and the CBF will ensure that we stay within the limits (+ some margin)</p> <p>This uses a single-integrator reduced model of the manipulator dynamics. We define the state as the joint positions and assume that we can directly control the joint velocities i.e. z = [q1, q2, q3] and u = [q1_dot, q2_dot, q3_dot]</p>"},{"location":"api/joint_limits_demo/#cbfpy.examples.joint_limits_demo.JointLimitsConfig","title":"<code>JointLimitsConfig</code>","text":"<p>               Bases: <code>CBFConfig</code></p> <p>Config for the 3-DOF arm, avoiding its joint limits using velocity control</p> Source code in <code>cbfpy/examples/joint_limits_demo.py</code> <pre><code>class JointLimitsConfig(CBFConfig):\n    \"\"\"Config for the 3-DOF arm, avoiding its joint limits using velocity control\"\"\"\n\n    def __init__(self):\n        self.num_joints = 3\n        # Joint limit values from the URDF\n        self.q_min = -np.pi / 2 * np.ones(self.num_joints)\n        self.q_max = np.pi / 2 * np.ones(self.num_joints)\n        # Pad joint limts (to better evauate CBF performance)\n        self.padding = 0.3\n        super().__init__(n=self.num_joints, m=self.num_joints)\n\n    def f(self, z):\n        return jnp.zeros(self.num_joints)\n\n    def g(self, z):\n        return jnp.eye(self.num_joints)\n\n    def h_1(self, z):\n        q = z\n        return jnp.concatenate(\n            [self.q_max - q - self.padding, q - self.q_min - self.padding]\n        )\n</code></pre>"},{"location":"api/joint_limits_demo/#cbfpy.examples.joint_limits_demo.nominal_controller","title":"<code>nominal_controller(q, q_des)</code>","text":"<p>Very simple proportional controller: Commands joint velocities to reduce a position error</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>Joint positions, shape (num_joints,)</p> required <code>q_des</code> <code>Array</code> <p>Desired joint positions, shape (num_joints,)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Joint velocity command, shape (num_joints,)</p> Source code in <code>cbfpy/examples/joint_limits_demo.py</code> <pre><code>def nominal_controller(q: Array, q_des: Array) -&gt; Array:\n    \"\"\"Very simple proportional controller: Commands joint velocities to reduce a position error\n\n    Args:\n        q (Array): Joint positions, shape (num_joints,)\n        q_des (Array): Desired joint positions, shape (num_joints,)\n\n    Returns:\n        Array: Joint velocity command, shape (num_joints,)\n    \"\"\"\n    k = 1.0\n    return k * (q_des - q)\n</code></pre>"},{"location":"api/point_robot_demo/","title":"Point Robot: Safe Set","text":""},{"location":"api/point_robot_demo/#cbfpy.examples.point_robot_demo","title":"<code>cbfpy.examples.point_robot_demo</code>","text":""},{"location":"api/point_robot_demo/#cbfpy.examples.point_robot_demo--point-robot-safe-set-containment-demo","title":"Point Robot Safe-Set Containment Demo","text":"<p>Demo of a point robot in 3D constrained to lie within a box via a CBF safety filter on a PD controller</p> <p>We define the state z as [x, y, z, vx, vy, vz] and the control u as [Fx, Fy, Fz]</p> <p>The dynamics are that of a simple double integrator: z_dot = [vx, vy, vz, 0, 0, 0] + [0, 0, 0, Fx/m, Fy/m, Fz/m]</p> <p>In matrix form, this can be expressed as z_dot = A z + B u with A and B as implemented in the config.</p> <p>The safety constraints are set as an upper and lower bound on the position of the robot.</p> <p>This is a relative-degree-2 system, so we use the RD2 version of the CBF constraints.</p>"},{"location":"api/point_robot_demo/#cbfpy.examples.point_robot_demo.PointRobotConfig","title":"<code>PointRobotConfig</code>","text":"<p>               Bases: <code>CBFConfig</code></p> <p>Configuration for the 3D 'point-robot-in-a-box' example.</p> Source code in <code>cbfpy/examples/point_robot_demo.py</code> <pre><code>class PointRobotConfig(CBFConfig):\n    \"\"\"Configuration for the 3D 'point-robot-in-a-box' example.\"\"\"\n\n    def __init__(self):\n        self.mass = 1.0\n        self.pos_min = jnp.array([-1.0, -1.0, -1.0])\n        self.pos_max = jnp.array([1.0, 1.0, 1.0])\n        super().__init__(n=6, m=3)\n\n    def f(self, z):\n        A = jnp.block(\n            [[jnp.zeros((3, 3)), jnp.eye(3)], [jnp.zeros((3, 3)), jnp.zeros((3, 3))]]\n        )\n        return A @ z\n\n    def g(self, z):\n        B = jnp.block([[jnp.zeros((3, 3))], [jnp.eye(3) / self.mass]])\n        return B\n\n    def h_2(self, z):\n        return jnp.concatenate([self.pos_max - z[:3], z[:3] - self.pos_min])\n</code></pre>"},{"location":"api/point_robot_demo/#cbfpy.examples.point_robot_demo.nominal_controller","title":"<code>nominal_controller(z, z_des)</code>","text":"<p>A simple PD controller for the point robot.</p> <p>This is unsafe without the CBF, as there is no guarantee that the robot will stay within the safe region</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The current state of the robot [x, y, z, vx, vy, vz]</p> required <code>z_des</code> <code>ArrayLike</code> <p>The desired state of the robot [x_des, y_des, z_des, vx_des, vy_des, vz_des]</p> required Source code in <code>cbfpy/examples/point_robot_demo.py</code> <pre><code>@jax.jit\ndef nominal_controller(z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"A simple PD controller for the point robot.\n\n    This is unsafe without the CBF, as there is no guarantee that the robot will stay within the safe region\n\n    Args:\n        z (ArrayLike): The current state of the robot [x, y, z, vx, vy, vz]\n        z_des (ArrayLike): The desired state of the robot [x_des, y_des, z_des, vx_des, vy_des, vz_des]\n    \"\"\"\n    Kp = 1.0\n    Kd = 1.0\n    radius = 0.25\n    # We assume we are in our Pybullet simulation environment where we have two point robots loaded\n    # One is the robot we are controlling, and the other is the target robot, which is interactive via the GUI\n    # This will attempt to \"touch\" the target robot\n    pos_diff = z_des[:3] - z[:3]\n    des_pos = z_des[:3] - 2 * radius * pos_diff / jnp.linalg.norm(pos_diff)\n    u = -Kp * (z[:3] - des_pos) - Kd * (z[3:] - z_des[3:])\n    return u\n</code></pre>"},{"location":"api/point_robot_envs/","title":"Point Robot Envs","text":""},{"location":"api/point_robot_envs/#cbfpy.envs.point_robot_envs","title":"<code>cbfpy.envs.point_robot_envs</code>","text":""},{"location":"api/point_robot_envs/#cbfpy.envs.point_robot_envs--simulation-environments-for-point-robots","title":"Simulation environments for point robots","text":""},{"location":"api/point_robot_envs/#cbfpy.envs.point_robot_envs.PointRobotEnv","title":"<code>PointRobotEnv</code>","text":"<p>               Bases: <code>BaseEnv</code></p> <p>Simulation environment for a point robot trying to approach a target position in 3D, while remaining in a safe set defined as a box</p> <p>Parameters:</p> Name Type Description Default <code>xyz_min</code> <code>ArrayLike</code> <p>Minimum bounds of the safe region, shape (3,). Defaults to (-1.0, -1.0, -1.0)</p> <code>(-1.0, -1.0, -1.0)</code> <code>xyz_max</code> <code>ArrayLike</code> <p>Maximum bounds of the safe region, shape (3,). Defaults to (1.0, 1.0, 1.0)</p> <code>(1.0, 1.0, 1.0)</code> Source code in <code>cbfpy/envs/point_robot_envs.py</code> <pre><code>class PointRobotEnv(BaseEnv):\n    \"\"\"Simulation environment for a point robot trying to approach a target position in 3D,\n    while remaining in a safe set defined as a box\n\n    Args:\n        xyz_min (ArrayLike, optional): Minimum bounds of the safe region, shape (3,). Defaults to (-1.0, -1.0, -1.0)\n        xyz_max (ArrayLike, optional): Maximum bounds of the safe region, shape (3,). Defaults to (1.0, 1.0, 1.0)\n    \"\"\"\n\n    # Constants\n    # Based on the values in the point robot URDF\n    URDF = \"point_robot.urdf\"\n    RADIUS = 0.25\n    MASS = 1.0\n\n    def __init__(\n        self,\n        xyz_min: ArrayLike = (-1.0, -1.0, -1.0),\n        xyz_max: ArrayLike = (1.0, 1.0, 1.0),\n    ):\n        self.xyz_min = np.array(xyz_min)\n        self.xyz_max = np.array(xyz_max)\n        assert len(self.xyz_min) == len(self.xyz_max) == 3\n        with stdout_redirected(restore=False):\n            self.client: pybullet = BulletClient(pybullet.GUI)\n        self.client.setAdditionalSearchPath(find_assets_dir())\n        self.client.configureDebugVisualizer(self.client.COV_ENABLE_GUI, 0)\n        self.robot = self.client.loadURDF(self.URDF)\n        self.target = self.client.loadURDF(self.URDF, basePosition=(3, 1, 1))\n        self.client.changeVisualShape(self.target, -1, rgbaColor=[1, 0, 0, 1])\n        self.client.changeDynamics(self.target, -1, linearDamping=10, angularDamping=10)\n        self.box = visualize_3D_box(\n            [self.xyz_min - self.RADIUS, self.xyz_max + self.RADIUS],\n            rgba=(0, 1, 0, 0.5),\n        )\n\n        # For color determination\n        self.is_in_box = True\n        self.tol = 1e-3\n\n    def _update_color(self, robot_pos: ArrayLike) -&gt; None:\n        \"\"\"Update the color of the box depending on if the robot is inside or not (Green inside, red outside)\"\"\"\n        robot_pos = np.array(robot_pos)\n        if np.any(robot_pos &lt; self.xyz_min - self.tol) or np.any(\n            robot_pos &gt; self.xyz_max + self.tol\n        ):\n            if self.is_in_box:\n                self.client.changeVisualShape(self.box, -1, rgbaColor=[1, 0, 0, 0.5])\n            self.is_in_box = False\n        else:\n            if not self.is_in_box:\n                self.client.changeVisualShape(self.box, -1, rgbaColor=[0, 1, 0, 0.5])\n            self.is_in_box = True\n\n    def get_state(self) -&gt; Array:\n        robot_pos = self.client.getBasePositionAndOrientation(self.robot)[0]\n        robot_vel = self.client.getBaseVelocity(self.robot)[0]\n        self._update_color(robot_pos)\n        return np.array([*robot_pos, *robot_vel])\n\n    def get_desired_state(self) -&gt; Array:\n        target_pos = self.client.getBasePositionAndOrientation(self.target)[0]\n        target_vel = self.client.getBaseVelocity(self.target)[0]\n        return np.array([*target_pos, *target_vel])\n\n    def apply_control(self, u: Array) -&gt; None:\n        robot_pos = self.client.getBasePositionAndOrientation(self.robot)[0]\n        self.client.applyExternalForce(\n            self.robot, -1, u, robot_pos, self.client.WORLD_FRAME\n        )\n\n    def step(self):\n        self.client.stepSimulation()\n</code></pre>"},{"location":"api/point_robot_envs/#cbfpy.envs.point_robot_envs.PointRobotObstacleEnv","title":"<code>PointRobotObstacleEnv</code>","text":"<p>               Bases: <code>BaseEnv</code></p> <p>Simulation environment for a point robot avoiding a movable obstacle, while remaining in a safe set defined as a box</p> <p>Parameters:</p> Name Type Description Default <code>robot_pos</code> <code>ArrayLike</code> <p>Initial position of the robot. Defaults to (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>robot_vel</code> <code>ArrayLike</code> <p>Initial velocity of the robot. Defaults to (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>obstacle_pos</code> <code>ArrayLike</code> <p>Initial position of the obstacle. Defaults to (1, 1, 1).</p> <code>(1, 1, 1)</code> <code>obstacle_vel</code> <code>ArrayLike</code> <p>Initial velocity of the obstacle. Defaults to (-0.5, -0.6, -0.7).</p> <code>(-0.5, -0.6, -0.7)</code> <code>xyz_min</code> <code>ArrayLike</code> <p>Minimum bounds of the safe region, shape (3,). Defaults to (-1.0, -1.0, -1.0)</p> <code>(-1.0, -1.0, -1.0)</code> <code>xyz_max</code> <code>ArrayLike</code> <p>Maximum bounds of the safe region, shape (3,). Defaults to (1.0, 1.0, 1.0)</p> <code>(1.0, 1.0, 1.0)</code> Source code in <code>cbfpy/envs/point_robot_envs.py</code> <pre><code>class PointRobotObstacleEnv(BaseEnv):\n    \"\"\"Simulation environment for a point robot avoiding a movable obstacle,\n    while remaining in a safe set defined as a box\n\n    Args:\n        robot_pos (ArrayLike, optional): Initial position of the robot. Defaults to (0, 0, 0).\n        robot_vel (ArrayLike, optional): Initial velocity of the robot. Defaults to (0, 0, 0).\n        obstacle_pos (ArrayLike, optional): Initial position of the obstacle. Defaults to (1, 1, 1).\n        obstacle_vel (ArrayLike, optional): Initial velocity of the obstacle. Defaults to (-0.5, -0.6, -0.7).\n        xyz_min (ArrayLike, optional): Minimum bounds of the safe region, shape (3,). Defaults to (-1.0, -1.0, -1.0)\n        xyz_max (ArrayLike, optional): Maximum bounds of the safe region, shape (3,). Defaults to (1.0, 1.0, 1.0)\n    \"\"\"\n\n    # Constants\n    # Based on the values in the point robot URDF\n    URDF = \"point_robot.urdf\"\n    RADIUS = 0.25\n    MASS = 1.0\n\n    def __init__(\n        self,\n        robot_pos: ArrayLike = (0, 0, 0),\n        robot_vel: ArrayLike = (0, 0, 0),\n        obstacle_pos: ArrayLike = (1, 1, 1),\n        obstacle_vel: ArrayLike = (-0.5, -0.6, -0.7),\n        xyz_min: ArrayLike = (-1.0, -1.0, -1.0),\n        xyz_max: ArrayLike = (1.0, 1.0, 1.0),\n    ):\n        with stdout_redirected(restore=False):\n            self.client: pybullet = BulletClient(pybullet.GUI)\n        self.client.setAdditionalSearchPath(find_assets_dir())\n        self.client.configureDebugVisualizer(self.client.COV_ENABLE_GUI, 0)\n        self.robot = self.client.loadURDF(self.URDF, basePosition=robot_pos)\n        self.target = self.client.loadURDF(self.URDF, basePosition=obstacle_pos)\n        self.client.changeVisualShape(self.target, -1, rgbaColor=[1, 0, 0, 1])\n        self.client.changeDynamics(self.target, -1, angularDamping=10)\n        self.client.resetBaseVelocity(self.target, obstacle_vel, (0, 0, 0))\n        self.client.resetBaseVelocity(self.robot, robot_vel, (0, 0, 0))\n        self.client.addUserDebugPoints([[0, 0, 0]], [[1, 0, 0]], 10, 0)\n        self.xyz_min = np.array(xyz_min)\n        self.xyz_max = np.array(xyz_max)\n        self.box = visualize_3D_box(\n            [self.xyz_min - self.RADIUS, self.xyz_max + self.RADIUS],\n            rgba=(0, 1, 0, 0.5),\n        )\n\n    def get_state(self):\n        robot_pos = self.client.getBasePositionAndOrientation(self.robot)[0]\n        robot_vel = self.client.getBaseVelocity(self.robot)[0]\n        obstacle_pos = self.client.getBasePositionAndOrientation(self.target)[0]\n        obstacle_vel = self.client.getBaseVelocity(self.target)[0]\n        return np.array([*robot_pos, *robot_vel]), np.array(\n            [*obstacle_pos, *obstacle_vel]\n        )\n\n    def get_desired_state(self):\n        return np.zeros(6)\n\n    def apply_control(self, u):\n        robot_pos = self.client.getBasePositionAndOrientation(self.robot)[0]\n        self.client.applyExternalForce(\n            self.robot, -1, u, robot_pos, self.client.WORLD_FRAME\n        )\n\n    def step(self):\n        self.client.stepSimulation()\n</code></pre>"},{"location":"api/point_robot_obstacle_demo/","title":"Point Robot: Obstacle Avoidance","text":""},{"location":"api/point_robot_obstacle_demo/#cbfpy.examples.point_robot_obstacle_demo","title":"<code>cbfpy.examples.point_robot_obstacle_demo</code>","text":""},{"location":"api/point_robot_obstacle_demo/#cbfpy.examples.point_robot_obstacle_demo--point-robot-obstacle-avoidance-demo","title":"Point Robot Obstacle Avoidance Demo","text":"<p>Example of using a CBF + PD controller to control a point robot to reach the origin, while avoiding a moving obstacle and staying in a safe set.</p> <p>This demo is interactive: click and drag the obstacle to move it around.</p> <p>Here, we have double integrator dynamics: z = [position, velocity], u = [acceleration] and we also use the state of the obstacle as an input to the CBF: z_obs = [position, velocity]</p> <p>This example includes both relative-degree-1 and relative-degree-2 CBFs. Staying inside the safe-set box is RD2, since we have a positional barrier with acceleration inputs. Avoiding the obstacle is relative-degree-1, because this is based on the relative velocity between the two objects.</p>"},{"location":"api/point_robot_obstacle_demo/#cbfpy.examples.point_robot_obstacle_demo.PointRobotObstacleConfig","title":"<code>PointRobotObstacleConfig</code>","text":"<p>               Bases: <code>CBFConfig</code></p> <p>Configuration for the 3D 'point-robot-avoiding-an-obstacle' example.</p> Source code in <code>cbfpy/examples/point_robot_obstacle_demo.py</code> <pre><code>class PointRobotObstacleConfig(CBFConfig):\n    \"\"\"Configuration for the 3D 'point-robot-avoiding-an-obstacle' example.\"\"\"\n\n    def __init__(self):\n        self.mass = 1.0\n        self.robot_radius = 0.25\n        self.obstacle_radius = 0.25\n        init_z_obs = jnp.array([3.0, 1.0, 1.0, -0.1, -0.1, -0.1])\n        super().__init__(\n            n=6,  # State = [position, velocity]\n            m=3,  # Control = [force]\n            init_args=(init_z_obs,),\n        )\n\n    def f(self, z):\n        A = jnp.block(\n            [[jnp.zeros((3, 3)), jnp.eye(3)], [jnp.zeros((3, 3)), jnp.zeros((3, 3))]]\n        )\n        return A @ z\n\n    def g(self, z):\n        B = jnp.block([[jnp.zeros((3, 3))], [jnp.eye(3) / self.mass]])\n        return B\n\n    def h_1(self, z, z_obs):\n        # Distance between &gt;= obstacle radius + robot radius + deceleration distance\n        pos_robot = z[:3]\n        vel_robot = z[3:]\n        pos_obs = z_obs[:3]\n        vel_obs = z_obs[3:]\n        dist_between_centers = jnp.linalg.norm(pos_obs - pos_robot)\n        dir_obs_to_robot = (pos_robot - pos_obs) / dist_between_centers\n        collision_velocity_component = (vel_obs - vel_robot).T @ dir_obs_to_robot\n        lookahead_time = 2.0\n        padding = 0.1\n        return jnp.array(\n            [\n                dist_between_centers\n                - collision_velocity_component * lookahead_time\n                - self.obstacle_radius\n                - self.robot_radius\n                - padding\n            ]\n        )\n\n    def h_2(self, z, z_obs):\n        # Stay inside the safe set (a box)\n        pos_max = jnp.array([1.0, 1.0, 1.0])\n        pos_min = jnp.array([-1.0, -1.0, -1.0])\n        return jnp.concatenate([pos_max - z[:3], z[:3] - pos_min])\n\n    def alpha(self, h):\n        return 3 * h\n</code></pre>"},{"location":"api/point_robot_obstacle_demo/#cbfpy.examples.point_robot_obstacle_demo.nominal_controller","title":"<code>nominal_controller(z, z_des)</code>","text":"<p>A simple PD controller for the point robot.</p> <p>This is unsafe without the CBF, as there is no guarantee that the robot wil not collide with the obstacle</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>ArrayLike</code> <p>The current state of the robot [x, y, z, vx, vy, vz]</p> required <code>z_des</code> <code>ArrayLike</code> <p>The desired state of the robot [x_des, y_des, z_des, vx_des, vy_des, vz_des]</p> required Source code in <code>cbfpy/examples/point_robot_obstacle_demo.py</code> <pre><code>@jax.jit\ndef nominal_controller(z: ArrayLike, z_des: ArrayLike) -&gt; Array:\n    \"\"\"A simple PD controller for the point robot.\n\n    This is unsafe without the CBF, as there is no guarantee that the robot wil not collide with the obstacle\n\n    Args:\n        z (ArrayLike): The current state of the robot [x, y, z, vx, vy, vz]\n        z_des (ArrayLike): The desired state of the robot [x_des, y_des, z_des, vx_des, vy_des, vz_des]\n    \"\"\"\n    Kp = 1.0\n    Kd = 1.0\n    u = -Kp * (z[:3] - z_des[:3]) - Kd * (z[3:] - z_des[3:])\n    return u\n</code></pre>"}]}